// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/profiler/tfprof_log.proto

package tensorflow.tfprof;

public final class TfprofLog {
  private TfprofLog() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface CodeDefOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.CodeDef)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    java.util.List<tensorflow.tfprof.TfprofLog.CodeDef.Trace> 
        getTracesList();
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    tensorflow.tfprof.TfprofLog.CodeDef.Trace getTraces(int index);
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    int getTracesCount();
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    java.util.List<? extends tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder> 
        getTracesOrBuilderList();
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder getTracesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * It specifies the Python callstack that creates an op.
   * </pre>
   *
   * Protobuf type {@code tensorflow.tfprof.CodeDef}
   */
  public  static final class CodeDef extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.CodeDef)
      CodeDefOrBuilder {
    // Use CodeDef.newBuilder() to construct.
    private CodeDef(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CodeDef() {
      traces_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private CodeDef(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                traces_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.CodeDef.Trace>();
                mutable_bitField0_ |= 0x00000001;
              }
              traces_.add(
                  input.readMessage(tensorflow.tfprof.TfprofLog.CodeDef.Trace.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          traces_ = java.util.Collections.unmodifiableList(traces_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.CodeDef.class, tensorflow.tfprof.TfprofLog.CodeDef.Builder.class);
    }

    public interface TraceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.CodeDef.Trace)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * deprecated by file_id.
       * </pre>
       *
       * <code>string file = 1 [deprecated = true];</code>
       */
      @java.lang.Deprecated java.lang.String getFile();
      /**
       * <pre>
       * deprecated by file_id.
       * </pre>
       *
       * <code>string file = 1 [deprecated = true];</code>
       */
      @java.lang.Deprecated com.google.protobuf.ByteString
          getFileBytes();

      /**
       * <code>int64 file_id = 6;</code>
       */
      long getFileId();

      /**
       * <code>int32 lineno = 2;</code>
       */
      int getLineno();

      /**
       * <pre>
       * deprecated by function_id.
       * </pre>
       *
       * <code>string function = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated java.lang.String getFunction();
      /**
       * <pre>
       * deprecated by function_id.
       * </pre>
       *
       * <code>string function = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated com.google.protobuf.ByteString
          getFunctionBytes();

      /**
       * <code>int64 function_id = 7;</code>
       */
      long getFunctionId();

      /**
       * <pre>
       * deprecated line_id.
       * </pre>
       *
       * <code>string line = 4 [deprecated = true];</code>
       */
      @java.lang.Deprecated java.lang.String getLine();
      /**
       * <pre>
       * deprecated line_id.
       * </pre>
       *
       * <code>string line = 4 [deprecated = true];</code>
       */
      @java.lang.Deprecated com.google.protobuf.ByteString
          getLineBytes();

      /**
       * <code>int64 line_id = 8;</code>
       */
      long getLineId();

      /**
       * <code>int32 func_start_line = 5;</code>
       */
      int getFuncStartLine();
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.CodeDef.Trace}
     */
    public  static final class Trace extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:tensorflow.tfprof.CodeDef.Trace)
        TraceOrBuilder {
      // Use Trace.newBuilder() to construct.
      private Trace(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Trace() {
        file_ = "";
        fileId_ = 0L;
        lineno_ = 0;
        function_ = "";
        functionId_ = 0L;
        line_ = "";
        lineId_ = 0L;
        funcStartLine_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
      }
      private Trace(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        int mutable_bitField0_ = 0;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();

                file_ = s;
                break;
              }
              case 16: {

                lineno_ = input.readInt32();
                break;
              }
              case 26: {
                java.lang.String s = input.readStringRequireUtf8();

                function_ = s;
                break;
              }
              case 34: {
                java.lang.String s = input.readStringRequireUtf8();

                line_ = s;
                break;
              }
              case 40: {

                funcStartLine_ = input.readInt32();
                break;
              }
              case 48: {

                fileId_ = input.readInt64();
                break;
              }
              case 56: {

                functionId_ = input.readInt64();
                break;
              }
              case 64: {

                lineId_ = input.readInt64();
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_Trace_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_Trace_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.CodeDef.Trace.class, tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder.class);
      }

      public static final int FILE_FIELD_NUMBER = 1;
      private volatile java.lang.Object file_;
      /**
       * <pre>
       * deprecated by file_id.
       * </pre>
       *
       * <code>string file = 1 [deprecated = true];</code>
       */
      @java.lang.Deprecated public java.lang.String getFile() {
        java.lang.Object ref = file_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          file_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * deprecated by file_id.
       * </pre>
       *
       * <code>string file = 1 [deprecated = true];</code>
       */
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getFileBytes() {
        java.lang.Object ref = file_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          file_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int FILE_ID_FIELD_NUMBER = 6;
      private long fileId_;
      /**
       * <code>int64 file_id = 6;</code>
       */
      public long getFileId() {
        return fileId_;
      }

      public static final int LINENO_FIELD_NUMBER = 2;
      private int lineno_;
      /**
       * <code>int32 lineno = 2;</code>
       */
      public int getLineno() {
        return lineno_;
      }

      public static final int FUNCTION_FIELD_NUMBER = 3;
      private volatile java.lang.Object function_;
      /**
       * <pre>
       * deprecated by function_id.
       * </pre>
       *
       * <code>string function = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public java.lang.String getFunction() {
        java.lang.Object ref = function_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          function_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * deprecated by function_id.
       * </pre>
       *
       * <code>string function = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getFunctionBytes() {
        java.lang.Object ref = function_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          function_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int FUNCTION_ID_FIELD_NUMBER = 7;
      private long functionId_;
      /**
       * <code>int64 function_id = 7;</code>
       */
      public long getFunctionId() {
        return functionId_;
      }

      public static final int LINE_FIELD_NUMBER = 4;
      private volatile java.lang.Object line_;
      /**
       * <pre>
       * deprecated line_id.
       * </pre>
       *
       * <code>string line = 4 [deprecated = true];</code>
       */
      @java.lang.Deprecated public java.lang.String getLine() {
        java.lang.Object ref = line_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          line_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * deprecated line_id.
       * </pre>
       *
       * <code>string line = 4 [deprecated = true];</code>
       */
      @java.lang.Deprecated public com.google.protobuf.ByteString
          getLineBytes() {
        java.lang.Object ref = line_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          line_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int LINE_ID_FIELD_NUMBER = 8;
      private long lineId_;
      /**
       * <code>int64 line_id = 8;</code>
       */
      public long getLineId() {
        return lineId_;
      }

      public static final int FUNC_START_LINE_FIELD_NUMBER = 5;
      private int funcStartLine_;
      /**
       * <code>int32 func_start_line = 5;</code>
       */
      public int getFuncStartLine() {
        return funcStartLine_;
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!getFileBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, file_);
        }
        if (lineno_ != 0) {
          output.writeInt32(2, lineno_);
        }
        if (!getFunctionBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 3, function_);
        }
        if (!getLineBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 4, line_);
        }
        if (funcStartLine_ != 0) {
          output.writeInt32(5, funcStartLine_);
        }
        if (fileId_ != 0L) {
          output.writeInt64(6, fileId_);
        }
        if (functionId_ != 0L) {
          output.writeInt64(7, functionId_);
        }
        if (lineId_ != 0L) {
          output.writeInt64(8, lineId_);
        }
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!getFileBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, file_);
        }
        if (lineno_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(2, lineno_);
        }
        if (!getFunctionBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, function_);
        }
        if (!getLineBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, line_);
        }
        if (funcStartLine_ != 0) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(5, funcStartLine_);
        }
        if (fileId_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(6, fileId_);
        }
        if (functionId_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(7, functionId_);
        }
        if (lineId_ != 0L) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(8, lineId_);
        }
        memoizedSize = size;
        return size;
      }

      private static final long serialVersionUID = 0L;
      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof tensorflow.tfprof.TfprofLog.CodeDef.Trace)) {
          return super.equals(obj);
        }
        tensorflow.tfprof.TfprofLog.CodeDef.Trace other = (tensorflow.tfprof.TfprofLog.CodeDef.Trace) obj;

        boolean result = true;
        result = result && getFile()
            .equals(other.getFile());
        result = result && (getFileId()
            == other.getFileId());
        result = result && (getLineno()
            == other.getLineno());
        result = result && getFunction()
            .equals(other.getFunction());
        result = result && (getFunctionId()
            == other.getFunctionId());
        result = result && getLine()
            .equals(other.getLine());
        result = result && (getLineId()
            == other.getLineId());
        result = result && (getFuncStartLine()
            == other.getFuncStartLine());
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + FILE_FIELD_NUMBER;
        hash = (53 * hash) + getFile().hashCode();
        hash = (37 * hash) + FILE_ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getFileId());
        hash = (37 * hash) + LINENO_FIELD_NUMBER;
        hash = (53 * hash) + getLineno();
        hash = (37 * hash) + FUNCTION_FIELD_NUMBER;
        hash = (53 * hash) + getFunction().hashCode();
        hash = (37 * hash) + FUNCTION_ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getFunctionId());
        hash = (37 * hash) + LINE_FIELD_NUMBER;
        hash = (53 * hash) + getLine().hashCode();
        hash = (37 * hash) + LINE_ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getLineId());
        hash = (37 * hash) + FUNC_START_LINE_FIELD_NUMBER;
        hash = (53 * hash) + getFuncStartLine();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(tensorflow.tfprof.TfprofLog.CodeDef.Trace prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code tensorflow.tfprof.CodeDef.Trace}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.CodeDef.Trace)
          tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_Trace_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_Trace_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  tensorflow.tfprof.TfprofLog.CodeDef.Trace.class, tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder.class);
        }

        // Construct using tensorflow.tfprof.TfprofLog.CodeDef.Trace.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          file_ = "";

          fileId_ = 0L;

          lineno_ = 0;

          function_ = "";

          functionId_ = 0L;

          line_ = "";

          lineId_ = 0L;

          funcStartLine_ = 0;

          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_Trace_descriptor;
        }

        public tensorflow.tfprof.TfprofLog.CodeDef.Trace getDefaultInstanceForType() {
          return tensorflow.tfprof.TfprofLog.CodeDef.Trace.getDefaultInstance();
        }

        public tensorflow.tfprof.TfprofLog.CodeDef.Trace build() {
          tensorflow.tfprof.TfprofLog.CodeDef.Trace result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public tensorflow.tfprof.TfprofLog.CodeDef.Trace buildPartial() {
          tensorflow.tfprof.TfprofLog.CodeDef.Trace result = new tensorflow.tfprof.TfprofLog.CodeDef.Trace(this);
          result.file_ = file_;
          result.fileId_ = fileId_;
          result.lineno_ = lineno_;
          result.function_ = function_;
          result.functionId_ = functionId_;
          result.line_ = line_;
          result.lineId_ = lineId_;
          result.funcStartLine_ = funcStartLine_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof tensorflow.tfprof.TfprofLog.CodeDef.Trace) {
            return mergeFrom((tensorflow.tfprof.TfprofLog.CodeDef.Trace)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(tensorflow.tfprof.TfprofLog.CodeDef.Trace other) {
          if (other == tensorflow.tfprof.TfprofLog.CodeDef.Trace.getDefaultInstance()) return this;
          if (!other.getFile().isEmpty()) {
            file_ = other.file_;
            onChanged();
          }
          if (other.getFileId() != 0L) {
            setFileId(other.getFileId());
          }
          if (other.getLineno() != 0) {
            setLineno(other.getLineno());
          }
          if (!other.getFunction().isEmpty()) {
            function_ = other.function_;
            onChanged();
          }
          if (other.getFunctionId() != 0L) {
            setFunctionId(other.getFunctionId());
          }
          if (!other.getLine().isEmpty()) {
            line_ = other.line_;
            onChanged();
          }
          if (other.getLineId() != 0L) {
            setLineId(other.getLineId());
          }
          if (other.getFuncStartLine() != 0) {
            setFuncStartLine(other.getFuncStartLine());
          }
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          tensorflow.tfprof.TfprofLog.CodeDef.Trace parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (tensorflow.tfprof.TfprofLog.CodeDef.Trace) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private java.lang.Object file_ = "";
        /**
         * <pre>
         * deprecated by file_id.
         * </pre>
         *
         * <code>string file = 1 [deprecated = true];</code>
         */
        @java.lang.Deprecated public java.lang.String getFile() {
          java.lang.Object ref = file_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            file_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * deprecated by file_id.
         * </pre>
         *
         * <code>string file = 1 [deprecated = true];</code>
         */
        @java.lang.Deprecated public com.google.protobuf.ByteString
            getFileBytes() {
          java.lang.Object ref = file_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            file_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * deprecated by file_id.
         * </pre>
         *
         * <code>string file = 1 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setFile(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          file_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * deprecated by file_id.
         * </pre>
         *
         * <code>string file = 1 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder clearFile() {
          
          file_ = getDefaultInstance().getFile();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * deprecated by file_id.
         * </pre>
         *
         * <code>string file = 1 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setFileBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          file_ = value;
          onChanged();
          return this;
        }

        private long fileId_ ;
        /**
         * <code>int64 file_id = 6;</code>
         */
        public long getFileId() {
          return fileId_;
        }
        /**
         * <code>int64 file_id = 6;</code>
         */
        public Builder setFileId(long value) {
          
          fileId_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int64 file_id = 6;</code>
         */
        public Builder clearFileId() {
          
          fileId_ = 0L;
          onChanged();
          return this;
        }

        private int lineno_ ;
        /**
         * <code>int32 lineno = 2;</code>
         */
        public int getLineno() {
          return lineno_;
        }
        /**
         * <code>int32 lineno = 2;</code>
         */
        public Builder setLineno(int value) {
          
          lineno_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int32 lineno = 2;</code>
         */
        public Builder clearLineno() {
          
          lineno_ = 0;
          onChanged();
          return this;
        }

        private java.lang.Object function_ = "";
        /**
         * <pre>
         * deprecated by function_id.
         * </pre>
         *
         * <code>string function = 3 [deprecated = true];</code>
         */
        @java.lang.Deprecated public java.lang.String getFunction() {
          java.lang.Object ref = function_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            function_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * deprecated by function_id.
         * </pre>
         *
         * <code>string function = 3 [deprecated = true];</code>
         */
        @java.lang.Deprecated public com.google.protobuf.ByteString
            getFunctionBytes() {
          java.lang.Object ref = function_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            function_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * deprecated by function_id.
         * </pre>
         *
         * <code>string function = 3 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setFunction(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          function_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * deprecated by function_id.
         * </pre>
         *
         * <code>string function = 3 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder clearFunction() {
          
          function_ = getDefaultInstance().getFunction();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * deprecated by function_id.
         * </pre>
         *
         * <code>string function = 3 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setFunctionBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          function_ = value;
          onChanged();
          return this;
        }

        private long functionId_ ;
        /**
         * <code>int64 function_id = 7;</code>
         */
        public long getFunctionId() {
          return functionId_;
        }
        /**
         * <code>int64 function_id = 7;</code>
         */
        public Builder setFunctionId(long value) {
          
          functionId_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int64 function_id = 7;</code>
         */
        public Builder clearFunctionId() {
          
          functionId_ = 0L;
          onChanged();
          return this;
        }

        private java.lang.Object line_ = "";
        /**
         * <pre>
         * deprecated line_id.
         * </pre>
         *
         * <code>string line = 4 [deprecated = true];</code>
         */
        @java.lang.Deprecated public java.lang.String getLine() {
          java.lang.Object ref = line_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            line_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * deprecated line_id.
         * </pre>
         *
         * <code>string line = 4 [deprecated = true];</code>
         */
        @java.lang.Deprecated public com.google.protobuf.ByteString
            getLineBytes() {
          java.lang.Object ref = line_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            line_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * deprecated line_id.
         * </pre>
         *
         * <code>string line = 4 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setLine(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          line_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * deprecated line_id.
         * </pre>
         *
         * <code>string line = 4 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder clearLine() {
          
          line_ = getDefaultInstance().getLine();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * deprecated line_id.
         * </pre>
         *
         * <code>string line = 4 [deprecated = true];</code>
         */
        @java.lang.Deprecated public Builder setLineBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          line_ = value;
          onChanged();
          return this;
        }

        private long lineId_ ;
        /**
         * <code>int64 line_id = 8;</code>
         */
        public long getLineId() {
          return lineId_;
        }
        /**
         * <code>int64 line_id = 8;</code>
         */
        public Builder setLineId(long value) {
          
          lineId_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int64 line_id = 8;</code>
         */
        public Builder clearLineId() {
          
          lineId_ = 0L;
          onChanged();
          return this;
        }

        private int funcStartLine_ ;
        /**
         * <code>int32 func_start_line = 5;</code>
         */
        public int getFuncStartLine() {
          return funcStartLine_;
        }
        /**
         * <code>int32 func_start_line = 5;</code>
         */
        public Builder setFuncStartLine(int value) {
          
          funcStartLine_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int32 func_start_line = 5;</code>
         */
        public Builder clearFuncStartLine() {
          
          funcStartLine_ = 0;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return this;
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return this;
        }


        // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.CodeDef.Trace)
      }

      // @@protoc_insertion_point(class_scope:tensorflow.tfprof.CodeDef.Trace)
      private static final tensorflow.tfprof.TfprofLog.CodeDef.Trace DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.CodeDef.Trace();
      }

      public static tensorflow.tfprof.TfprofLog.CodeDef.Trace getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Trace>
          PARSER = new com.google.protobuf.AbstractParser<Trace>() {
        public Trace parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
            return new Trace(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Trace> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Trace> getParserForType() {
        return PARSER;
      }

      public tensorflow.tfprof.TfprofLog.CodeDef.Trace getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int TRACES_FIELD_NUMBER = 1;
    private java.util.List<tensorflow.tfprof.TfprofLog.CodeDef.Trace> traces_;
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    public java.util.List<tensorflow.tfprof.TfprofLog.CodeDef.Trace> getTracesList() {
      return traces_;
    }
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    public java.util.List<? extends tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder> 
        getTracesOrBuilderList() {
      return traces_;
    }
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    public int getTracesCount() {
      return traces_.size();
    }
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    public tensorflow.tfprof.TfprofLog.CodeDef.Trace getTraces(int index) {
      return traces_.get(index);
    }
    /**
     * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
     */
    public tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder getTracesOrBuilder(
        int index) {
      return traces_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < traces_.size(); i++) {
        output.writeMessage(1, traces_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < traces_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, traces_.get(i));
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.CodeDef)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.CodeDef other = (tensorflow.tfprof.TfprofLog.CodeDef) obj;

      boolean result = true;
      result = result && getTracesList()
          .equals(other.getTracesList());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getTracesCount() > 0) {
        hash = (37 * hash) + TRACES_FIELD_NUMBER;
        hash = (53 * hash) + getTracesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.CodeDef parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.CodeDef prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * It specifies the Python callstack that creates an op.
     * </pre>
     *
     * Protobuf type {@code tensorflow.tfprof.CodeDef}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.CodeDef)
        tensorflow.tfprof.TfprofLog.CodeDefOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.CodeDef.class, tensorflow.tfprof.TfprofLog.CodeDef.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.CodeDef.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTracesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (tracesBuilder_ == null) {
          traces_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          tracesBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_CodeDef_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.CodeDef getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.CodeDef build() {
        tensorflow.tfprof.TfprofLog.CodeDef result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.CodeDef buildPartial() {
        tensorflow.tfprof.TfprofLog.CodeDef result = new tensorflow.tfprof.TfprofLog.CodeDef(this);
        int from_bitField0_ = bitField0_;
        if (tracesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            traces_ = java.util.Collections.unmodifiableList(traces_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.traces_ = traces_;
        } else {
          result.traces_ = tracesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.CodeDef) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.CodeDef)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.CodeDef other) {
        if (other == tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance()) return this;
        if (tracesBuilder_ == null) {
          if (!other.traces_.isEmpty()) {
            if (traces_.isEmpty()) {
              traces_ = other.traces_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureTracesIsMutable();
              traces_.addAll(other.traces_);
            }
            onChanged();
          }
        } else {
          if (!other.traces_.isEmpty()) {
            if (tracesBuilder_.isEmpty()) {
              tracesBuilder_.dispose();
              tracesBuilder_ = null;
              traces_ = other.traces_;
              bitField0_ = (bitField0_ & ~0x00000001);
              tracesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTracesFieldBuilder() : null;
            } else {
              tracesBuilder_.addAllMessages(other.traces_);
            }
          }
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.CodeDef parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.CodeDef) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<tensorflow.tfprof.TfprofLog.CodeDef.Trace> traces_ =
        java.util.Collections.emptyList();
      private void ensureTracesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          traces_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.CodeDef.Trace>(traces_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.CodeDef.Trace, tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder, tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder> tracesBuilder_;

      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.CodeDef.Trace> getTracesList() {
        if (tracesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(traces_);
        } else {
          return tracesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public int getTracesCount() {
        if (tracesBuilder_ == null) {
          return traces_.size();
        } else {
          return tracesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef.Trace getTraces(int index) {
        if (tracesBuilder_ == null) {
          return traces_.get(index);
        } else {
          return tracesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder setTraces(
          int index, tensorflow.tfprof.TfprofLog.CodeDef.Trace value) {
        if (tracesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTracesIsMutable();
          traces_.set(index, value);
          onChanged();
        } else {
          tracesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder setTraces(
          int index, tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder builderForValue) {
        if (tracesBuilder_ == null) {
          ensureTracesIsMutable();
          traces_.set(index, builderForValue.build());
          onChanged();
        } else {
          tracesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder addTraces(tensorflow.tfprof.TfprofLog.CodeDef.Trace value) {
        if (tracesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTracesIsMutable();
          traces_.add(value);
          onChanged();
        } else {
          tracesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder addTraces(
          int index, tensorflow.tfprof.TfprofLog.CodeDef.Trace value) {
        if (tracesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTracesIsMutable();
          traces_.add(index, value);
          onChanged();
        } else {
          tracesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder addTraces(
          tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder builderForValue) {
        if (tracesBuilder_ == null) {
          ensureTracesIsMutable();
          traces_.add(builderForValue.build());
          onChanged();
        } else {
          tracesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder addTraces(
          int index, tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder builderForValue) {
        if (tracesBuilder_ == null) {
          ensureTracesIsMutable();
          traces_.add(index, builderForValue.build());
          onChanged();
        } else {
          tracesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder addAllTraces(
          java.lang.Iterable<? extends tensorflow.tfprof.TfprofLog.CodeDef.Trace> values) {
        if (tracesBuilder_ == null) {
          ensureTracesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, traces_);
          onChanged();
        } else {
          tracesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder clearTraces() {
        if (tracesBuilder_ == null) {
          traces_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          tracesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public Builder removeTraces(int index) {
        if (tracesBuilder_ == null) {
          ensureTracesIsMutable();
          traces_.remove(index);
          onChanged();
        } else {
          tracesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder getTracesBuilder(
          int index) {
        return getTracesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder getTracesOrBuilder(
          int index) {
        if (tracesBuilder_ == null) {
          return traces_.get(index);  } else {
          return tracesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public java.util.List<? extends tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder> 
           getTracesOrBuilderList() {
        if (tracesBuilder_ != null) {
          return tracesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(traces_);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder addTracesBuilder() {
        return getTracesFieldBuilder().addBuilder(
            tensorflow.tfprof.TfprofLog.CodeDef.Trace.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder addTracesBuilder(
          int index) {
        return getTracesFieldBuilder().addBuilder(
            index, tensorflow.tfprof.TfprofLog.CodeDef.Trace.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder> 
           getTracesBuilderList() {
        return getTracesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.CodeDef.Trace, tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder, tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder> 
          getTracesFieldBuilder() {
        if (tracesBuilder_ == null) {
          tracesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              tensorflow.tfprof.TfprofLog.CodeDef.Trace, tensorflow.tfprof.TfprofLog.CodeDef.Trace.Builder, tensorflow.tfprof.TfprofLog.CodeDef.TraceOrBuilder>(
                  traces_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          traces_ = null;
        }
        return tracesBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.CodeDef)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.CodeDef)
    private static final tensorflow.tfprof.TfprofLog.CodeDef DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.CodeDef();
    }

    public static tensorflow.tfprof.TfprofLog.CodeDef getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CodeDef>
        PARSER = new com.google.protobuf.AbstractParser<CodeDef>() {
      public CodeDef parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new CodeDef(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CodeDef> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CodeDef> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.CodeDef getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OpLogEntryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.OpLogEntry)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * op name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * op name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * float_ops is filled by tfprof Python API when called. It requires the
     * op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
     * implemented.
     * </pre>
     *
     * <code>int64 float_ops = 2;</code>
     */
    long getFloatOps();

    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    java.util.List<java.lang.String>
        getTypesList();
    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    int getTypesCount();
    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    java.lang.String getTypes(int index);
    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    com.google.protobuf.ByteString
        getTypesBytes(int index);

    /**
     * <pre>
     * Used to support tfprof "code" view.
     * </pre>
     *
     * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
     */
    boolean hasCodeDef();
    /**
     * <pre>
     * Used to support tfprof "code" view.
     * </pre>
     *
     * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
     */
    tensorflow.tfprof.TfprofLog.CodeDef getCodeDef();
    /**
     * <pre>
     * Used to support tfprof "code" view.
     * </pre>
     *
     * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
     */
    tensorflow.tfprof.TfprofLog.CodeDefOrBuilder getCodeDefOrBuilder();
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.OpLogEntry}
   */
  public  static final class OpLogEntry extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.OpLogEntry)
      OpLogEntryOrBuilder {
    // Use OpLogEntry.newBuilder() to construct.
    private OpLogEntry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OpLogEntry() {
      name_ = "";
      floatOps_ = 0L;
      types_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private OpLogEntry(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 16: {

              floatOps_ = input.readInt64();
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                types_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              types_.add(s);
              break;
            }
            case 34: {
              tensorflow.tfprof.TfprofLog.CodeDef.Builder subBuilder = null;
              if (codeDef_ != null) {
                subBuilder = codeDef_.toBuilder();
              }
              codeDef_ = input.readMessage(tensorflow.tfprof.TfprofLog.CodeDef.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(codeDef_);
                codeDef_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          types_ = types_.getUnmodifiableView();
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogEntry_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogEntry_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.OpLogEntry.class, tensorflow.tfprof.TfprofLog.OpLogEntry.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * op name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * op name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FLOAT_OPS_FIELD_NUMBER = 2;
    private long floatOps_;
    /**
     * <pre>
     * float_ops is filled by tfprof Python API when called. It requires the
     * op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
     * implemented.
     * </pre>
     *
     * <code>int64 float_ops = 2;</code>
     */
    public long getFloatOps() {
      return floatOps_;
    }

    public static final int TYPES_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList types_;
    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getTypesList() {
      return types_;
    }
    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    public int getTypesCount() {
      return types_.size();
    }
    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    public java.lang.String getTypes(int index) {
      return types_.get(index);
    }
    /**
     * <pre>
     * User can define extra op type information for an op. This allows the user
     * to select a group of ops precisely using op_type as a key.
     * </pre>
     *
     * <code>repeated string types = 3;</code>
     */
    public com.google.protobuf.ByteString
        getTypesBytes(int index) {
      return types_.getByteString(index);
    }

    public static final int CODE_DEF_FIELD_NUMBER = 4;
    private tensorflow.tfprof.TfprofLog.CodeDef codeDef_;
    /**
     * <pre>
     * Used to support tfprof "code" view.
     * </pre>
     *
     * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
     */
    public boolean hasCodeDef() {
      return codeDef_ != null;
    }
    /**
     * <pre>
     * Used to support tfprof "code" view.
     * </pre>
     *
     * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
     */
    public tensorflow.tfprof.TfprofLog.CodeDef getCodeDef() {
      return codeDef_ == null ? tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance() : codeDef_;
    }
    /**
     * <pre>
     * Used to support tfprof "code" view.
     * </pre>
     *
     * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
     */
    public tensorflow.tfprof.TfprofLog.CodeDefOrBuilder getCodeDefOrBuilder() {
      return getCodeDef();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (floatOps_ != 0L) {
        output.writeInt64(2, floatOps_);
      }
      for (int i = 0; i < types_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, types_.getRaw(i));
      }
      if (codeDef_ != null) {
        output.writeMessage(4, getCodeDef());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (floatOps_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, floatOps_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < types_.size(); i++) {
          dataSize += computeStringSizeNoTag(types_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getTypesList().size();
      }
      if (codeDef_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getCodeDef());
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.OpLogEntry)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.OpLogEntry other = (tensorflow.tfprof.TfprofLog.OpLogEntry) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && (getFloatOps()
          == other.getFloatOps());
      result = result && getTypesList()
          .equals(other.getTypesList());
      result = result && (hasCodeDef() == other.hasCodeDef());
      if (hasCodeDef()) {
        result = result && getCodeDef()
            .equals(other.getCodeDef());
      }
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + FLOAT_OPS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFloatOps());
      if (getTypesCount() > 0) {
        hash = (37 * hash) + TYPES_FIELD_NUMBER;
        hash = (53 * hash) + getTypesList().hashCode();
      }
      if (hasCodeDef()) {
        hash = (37 * hash) + CODE_DEF_FIELD_NUMBER;
        hash = (53 * hash) + getCodeDef().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogEntry parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.OpLogEntry prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.OpLogEntry}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.OpLogEntry)
        tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogEntry_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogEntry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.OpLogEntry.class, tensorflow.tfprof.TfprofLog.OpLogEntry.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.OpLogEntry.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        floatOps_ = 0L;

        types_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (codeDefBuilder_ == null) {
          codeDef_ = null;
        } else {
          codeDef_ = null;
          codeDefBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogEntry_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.OpLogEntry getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.OpLogEntry.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.OpLogEntry build() {
        tensorflow.tfprof.TfprofLog.OpLogEntry result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.OpLogEntry buildPartial() {
        tensorflow.tfprof.TfprofLog.OpLogEntry result = new tensorflow.tfprof.TfprofLog.OpLogEntry(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.name_ = name_;
        result.floatOps_ = floatOps_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          types_ = types_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.types_ = types_;
        if (codeDefBuilder_ == null) {
          result.codeDef_ = codeDef_;
        } else {
          result.codeDef_ = codeDefBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.OpLogEntry) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.OpLogEntry)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.OpLogEntry other) {
        if (other == tensorflow.tfprof.TfprofLog.OpLogEntry.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.getFloatOps() != 0L) {
          setFloatOps(other.getFloatOps());
        }
        if (!other.types_.isEmpty()) {
          if (types_.isEmpty()) {
            types_ = other.types_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureTypesIsMutable();
            types_.addAll(other.types_);
          }
          onChanged();
        }
        if (other.hasCodeDef()) {
          mergeCodeDef(other.getCodeDef());
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.OpLogEntry parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.OpLogEntry) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * op name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * op name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * op name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * op name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * op name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private long floatOps_ ;
      /**
       * <pre>
       * float_ops is filled by tfprof Python API when called. It requires the
       * op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
       * implemented.
       * </pre>
       *
       * <code>int64 float_ops = 2;</code>
       */
      public long getFloatOps() {
        return floatOps_;
      }
      /**
       * <pre>
       * float_ops is filled by tfprof Python API when called. It requires the
       * op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
       * implemented.
       * </pre>
       *
       * <code>int64 float_ops = 2;</code>
       */
      public Builder setFloatOps(long value) {
        
        floatOps_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * float_ops is filled by tfprof Python API when called. It requires the
       * op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
       * implemented.
       * </pre>
       *
       * <code>int64 float_ops = 2;</code>
       */
      public Builder clearFloatOps() {
        
        floatOps_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList types_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureTypesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          types_ = new com.google.protobuf.LazyStringArrayList(types_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getTypesList() {
        return types_.getUnmodifiableView();
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public int getTypesCount() {
        return types_.size();
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public java.lang.String getTypes(int index) {
        return types_.get(index);
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public com.google.protobuf.ByteString
          getTypesBytes(int index) {
        return types_.getByteString(index);
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public Builder setTypes(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureTypesIsMutable();
        types_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public Builder addTypes(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureTypesIsMutable();
        types_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public Builder addAllTypes(
          java.lang.Iterable<java.lang.String> values) {
        ensureTypesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, types_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public Builder clearTypes() {
        types_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * User can define extra op type information for an op. This allows the user
       * to select a group of ops precisely using op_type as a key.
       * </pre>
       *
       * <code>repeated string types = 3;</code>
       */
      public Builder addTypesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureTypesIsMutable();
        types_.add(value);
        onChanged();
        return this;
      }

      private tensorflow.tfprof.TfprofLog.CodeDef codeDef_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.CodeDef, tensorflow.tfprof.TfprofLog.CodeDef.Builder, tensorflow.tfprof.TfprofLog.CodeDefOrBuilder> codeDefBuilder_;
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public boolean hasCodeDef() {
        return codeDefBuilder_ != null || codeDef_ != null;
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef getCodeDef() {
        if (codeDefBuilder_ == null) {
          return codeDef_ == null ? tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance() : codeDef_;
        } else {
          return codeDefBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public Builder setCodeDef(tensorflow.tfprof.TfprofLog.CodeDef value) {
        if (codeDefBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          codeDef_ = value;
          onChanged();
        } else {
          codeDefBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public Builder setCodeDef(
          tensorflow.tfprof.TfprofLog.CodeDef.Builder builderForValue) {
        if (codeDefBuilder_ == null) {
          codeDef_ = builderForValue.build();
          onChanged();
        } else {
          codeDefBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public Builder mergeCodeDef(tensorflow.tfprof.TfprofLog.CodeDef value) {
        if (codeDefBuilder_ == null) {
          if (codeDef_ != null) {
            codeDef_ =
              tensorflow.tfprof.TfprofLog.CodeDef.newBuilder(codeDef_).mergeFrom(value).buildPartial();
          } else {
            codeDef_ = value;
          }
          onChanged();
        } else {
          codeDefBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public Builder clearCodeDef() {
        if (codeDefBuilder_ == null) {
          codeDef_ = null;
          onChanged();
        } else {
          codeDef_ = null;
          codeDefBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef.Builder getCodeDefBuilder() {
        
        onChanged();
        return getCodeDefFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDefOrBuilder getCodeDefOrBuilder() {
        if (codeDefBuilder_ != null) {
          return codeDefBuilder_.getMessageOrBuilder();
        } else {
          return codeDef_ == null ?
              tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance() : codeDef_;
        }
      }
      /**
       * <pre>
       * Used to support tfprof "code" view.
       * </pre>
       *
       * <code>.tensorflow.tfprof.CodeDef code_def = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.CodeDef, tensorflow.tfprof.TfprofLog.CodeDef.Builder, tensorflow.tfprof.TfprofLog.CodeDefOrBuilder> 
          getCodeDefFieldBuilder() {
        if (codeDefBuilder_ == null) {
          codeDefBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              tensorflow.tfprof.TfprofLog.CodeDef, tensorflow.tfprof.TfprofLog.CodeDef.Builder, tensorflow.tfprof.TfprofLog.CodeDefOrBuilder>(
                  getCodeDef(),
                  getParentForChildren(),
                  isClean());
          codeDef_ = null;
        }
        return codeDefBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.OpLogEntry)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.OpLogEntry)
    private static final tensorflow.tfprof.TfprofLog.OpLogEntry DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.OpLogEntry();
    }

    public static tensorflow.tfprof.TfprofLog.OpLogEntry getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OpLogEntry>
        PARSER = new com.google.protobuf.AbstractParser<OpLogEntry>() {
      public OpLogEntry parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new OpLogEntry(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<OpLogEntry> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OpLogEntry> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.OpLogEntry getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OpLogProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.OpLogProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    java.util.List<tensorflow.tfprof.TfprofLog.OpLogEntry> 
        getLogEntriesList();
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    tensorflow.tfprof.TfprofLog.OpLogEntry getLogEntries(int index);
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    int getLogEntriesCount();
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    java.util.List<? extends tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder> 
        getLogEntriesOrBuilderList();
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder getLogEntriesOrBuilder(
        int index);

    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */
    int getIdToStringCount();
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */
    boolean containsIdToString(
        long key);
    /**
     * Use {@link #getIdToStringMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, java.lang.String>
    getIdToString();
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */
    java.util.Map<java.lang.Long, java.lang.String>
    getIdToStringMap();
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */

    java.lang.String getIdToStringOrDefault(
        long key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */

    java.lang.String getIdToStringOrThrow(
        long key);
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.OpLogProto}
   */
  public  static final class OpLogProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.OpLogProto)
      OpLogProtoOrBuilder {
    // Use OpLogProto.newBuilder() to construct.
    private OpLogProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OpLogProto() {
      logEntries_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private OpLogProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                logEntries_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.OpLogEntry>();
                mutable_bitField0_ |= 0x00000001;
              }
              logEntries_.add(
                  input.readMessage(tensorflow.tfprof.TfprofLog.OpLogEntry.parser(), extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                idToString_ = com.google.protobuf.MapField.newMapField(
                    IdToStringDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.Long, java.lang.String>
              idToString__ = input.readMessage(
                  IdToStringDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              idToString_.getMutableMap().put(
                  idToString__.getKey(), idToString__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          logEntries_ = java.util.Collections.unmodifiableList(logEntries_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogProto_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetIdToString();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.OpLogProto.class, tensorflow.tfprof.TfprofLog.OpLogProto.Builder.class);
    }

    public static final int LOG_ENTRIES_FIELD_NUMBER = 1;
    private java.util.List<tensorflow.tfprof.TfprofLog.OpLogEntry> logEntries_;
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    public java.util.List<tensorflow.tfprof.TfprofLog.OpLogEntry> getLogEntriesList() {
      return logEntries_;
    }
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    public java.util.List<? extends tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder> 
        getLogEntriesOrBuilderList() {
      return logEntries_;
    }
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    public int getLogEntriesCount() {
      return logEntries_.size();
    }
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    public tensorflow.tfprof.TfprofLog.OpLogEntry getLogEntries(int index) {
      return logEntries_.get(index);
    }
    /**
     * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
     */
    public tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder getLogEntriesOrBuilder(
        int index) {
      return logEntries_.get(index);
    }

    public static final int ID_TO_STRING_FIELD_NUMBER = 2;
    private static final class IdToStringDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Long, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Long, java.lang.String>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogProto_IdToStringEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.Long, java.lang.String> idToString_;
    private com.google.protobuf.MapField<java.lang.Long, java.lang.String>
    internalGetIdToString() {
      if (idToString_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            IdToStringDefaultEntryHolder.defaultEntry);
      }
      return idToString_;
    }

    public int getIdToStringCount() {
      return internalGetIdToString().getMap().size();
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */

    public boolean containsIdToString(
        long key) {
      
      return internalGetIdToString().getMap().containsKey(key);
    }
    /**
     * Use {@link #getIdToStringMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, java.lang.String> getIdToString() {
      return getIdToStringMap();
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */

    public java.util.Map<java.lang.Long, java.lang.String> getIdToStringMap() {
      return internalGetIdToString().getMap();
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */

    public java.lang.String getIdToStringOrDefault(
        long key,
        java.lang.String defaultValue) {
      
      java.util.Map<java.lang.Long, java.lang.String> map =
          internalGetIdToString().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
     */

    public java.lang.String getIdToStringOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, java.lang.String> map =
          internalGetIdToString().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < logEntries_.size(); i++) {
        output.writeMessage(1, logEntries_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeLongMapTo(
          output,
          internalGetIdToString(),
          IdToStringDefaultEntryHolder.defaultEntry,
          2);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < logEntries_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, logEntries_.get(i));
      }
      for (java.util.Map.Entry<java.lang.Long, java.lang.String> entry
           : internalGetIdToString().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Long, java.lang.String>
        idToString__ = IdToStringDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, idToString__);
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.OpLogProto)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.OpLogProto other = (tensorflow.tfprof.TfprofLog.OpLogProto) obj;

      boolean result = true;
      result = result && getLogEntriesList()
          .equals(other.getLogEntriesList());
      result = result && internalGetIdToString().equals(
          other.internalGetIdToString());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getLogEntriesCount() > 0) {
        hash = (37 * hash) + LOG_ENTRIES_FIELD_NUMBER;
        hash = (53 * hash) + getLogEntriesList().hashCode();
      }
      if (!internalGetIdToString().getMap().isEmpty()) {
        hash = (37 * hash) + ID_TO_STRING_FIELD_NUMBER;
        hash = (53 * hash) + internalGetIdToString().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.OpLogProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.OpLogProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.OpLogProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.OpLogProto)
        tensorflow.tfprof.TfprofLog.OpLogProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogProto_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetIdToString();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableIdToString();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.OpLogProto.class, tensorflow.tfprof.TfprofLog.OpLogProto.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.OpLogProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getLogEntriesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (logEntriesBuilder_ == null) {
          logEntries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          logEntriesBuilder_.clear();
        }
        internalGetMutableIdToString().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_OpLogProto_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.OpLogProto getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.OpLogProto.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.OpLogProto build() {
        tensorflow.tfprof.TfprofLog.OpLogProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.OpLogProto buildPartial() {
        tensorflow.tfprof.TfprofLog.OpLogProto result = new tensorflow.tfprof.TfprofLog.OpLogProto(this);
        int from_bitField0_ = bitField0_;
        if (logEntriesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            logEntries_ = java.util.Collections.unmodifiableList(logEntries_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.logEntries_ = logEntries_;
        } else {
          result.logEntries_ = logEntriesBuilder_.build();
        }
        result.idToString_ = internalGetIdToString();
        result.idToString_.makeImmutable();
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.OpLogProto) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.OpLogProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.OpLogProto other) {
        if (other == tensorflow.tfprof.TfprofLog.OpLogProto.getDefaultInstance()) return this;
        if (logEntriesBuilder_ == null) {
          if (!other.logEntries_.isEmpty()) {
            if (logEntries_.isEmpty()) {
              logEntries_ = other.logEntries_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureLogEntriesIsMutable();
              logEntries_.addAll(other.logEntries_);
            }
            onChanged();
          }
        } else {
          if (!other.logEntries_.isEmpty()) {
            if (logEntriesBuilder_.isEmpty()) {
              logEntriesBuilder_.dispose();
              logEntriesBuilder_ = null;
              logEntries_ = other.logEntries_;
              bitField0_ = (bitField0_ & ~0x00000001);
              logEntriesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getLogEntriesFieldBuilder() : null;
            } else {
              logEntriesBuilder_.addAllMessages(other.logEntries_);
            }
          }
        }
        internalGetMutableIdToString().mergeFrom(
            other.internalGetIdToString());
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.OpLogProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.OpLogProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<tensorflow.tfprof.TfprofLog.OpLogEntry> logEntries_ =
        java.util.Collections.emptyList();
      private void ensureLogEntriesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          logEntries_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.OpLogEntry>(logEntries_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.OpLogEntry, tensorflow.tfprof.TfprofLog.OpLogEntry.Builder, tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder> logEntriesBuilder_;

      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.OpLogEntry> getLogEntriesList() {
        if (logEntriesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(logEntries_);
        } else {
          return logEntriesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public int getLogEntriesCount() {
        if (logEntriesBuilder_ == null) {
          return logEntries_.size();
        } else {
          return logEntriesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.OpLogEntry getLogEntries(int index) {
        if (logEntriesBuilder_ == null) {
          return logEntries_.get(index);
        } else {
          return logEntriesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder setLogEntries(
          int index, tensorflow.tfprof.TfprofLog.OpLogEntry value) {
        if (logEntriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLogEntriesIsMutable();
          logEntries_.set(index, value);
          onChanged();
        } else {
          logEntriesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder setLogEntries(
          int index, tensorflow.tfprof.TfprofLog.OpLogEntry.Builder builderForValue) {
        if (logEntriesBuilder_ == null) {
          ensureLogEntriesIsMutable();
          logEntries_.set(index, builderForValue.build());
          onChanged();
        } else {
          logEntriesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder addLogEntries(tensorflow.tfprof.TfprofLog.OpLogEntry value) {
        if (logEntriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLogEntriesIsMutable();
          logEntries_.add(value);
          onChanged();
        } else {
          logEntriesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder addLogEntries(
          int index, tensorflow.tfprof.TfprofLog.OpLogEntry value) {
        if (logEntriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureLogEntriesIsMutable();
          logEntries_.add(index, value);
          onChanged();
        } else {
          logEntriesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder addLogEntries(
          tensorflow.tfprof.TfprofLog.OpLogEntry.Builder builderForValue) {
        if (logEntriesBuilder_ == null) {
          ensureLogEntriesIsMutable();
          logEntries_.add(builderForValue.build());
          onChanged();
        } else {
          logEntriesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder addLogEntries(
          int index, tensorflow.tfprof.TfprofLog.OpLogEntry.Builder builderForValue) {
        if (logEntriesBuilder_ == null) {
          ensureLogEntriesIsMutable();
          logEntries_.add(index, builderForValue.build());
          onChanged();
        } else {
          logEntriesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder addAllLogEntries(
          java.lang.Iterable<? extends tensorflow.tfprof.TfprofLog.OpLogEntry> values) {
        if (logEntriesBuilder_ == null) {
          ensureLogEntriesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, logEntries_);
          onChanged();
        } else {
          logEntriesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder clearLogEntries() {
        if (logEntriesBuilder_ == null) {
          logEntries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          logEntriesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public Builder removeLogEntries(int index) {
        if (logEntriesBuilder_ == null) {
          ensureLogEntriesIsMutable();
          logEntries_.remove(index);
          onChanged();
        } else {
          logEntriesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.OpLogEntry.Builder getLogEntriesBuilder(
          int index) {
        return getLogEntriesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder getLogEntriesOrBuilder(
          int index) {
        if (logEntriesBuilder_ == null) {
          return logEntries_.get(index);  } else {
          return logEntriesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public java.util.List<? extends tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder> 
           getLogEntriesOrBuilderList() {
        if (logEntriesBuilder_ != null) {
          return logEntriesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(logEntries_);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.OpLogEntry.Builder addLogEntriesBuilder() {
        return getLogEntriesFieldBuilder().addBuilder(
            tensorflow.tfprof.TfprofLog.OpLogEntry.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.OpLogEntry.Builder addLogEntriesBuilder(
          int index) {
        return getLogEntriesFieldBuilder().addBuilder(
            index, tensorflow.tfprof.TfprofLog.OpLogEntry.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.OpLogEntry.Builder> 
           getLogEntriesBuilderList() {
        return getLogEntriesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.OpLogEntry, tensorflow.tfprof.TfprofLog.OpLogEntry.Builder, tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder> 
          getLogEntriesFieldBuilder() {
        if (logEntriesBuilder_ == null) {
          logEntriesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              tensorflow.tfprof.TfprofLog.OpLogEntry, tensorflow.tfprof.TfprofLog.OpLogEntry.Builder, tensorflow.tfprof.TfprofLog.OpLogEntryOrBuilder>(
                  logEntries_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          logEntries_ = null;
        }
        return logEntriesBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.Long, java.lang.String> idToString_;
      private com.google.protobuf.MapField<java.lang.Long, java.lang.String>
      internalGetIdToString() {
        if (idToString_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              IdToStringDefaultEntryHolder.defaultEntry);
        }
        return idToString_;
      }
      private com.google.protobuf.MapField<java.lang.Long, java.lang.String>
      internalGetMutableIdToString() {
        onChanged();;
        if (idToString_ == null) {
          idToString_ = com.google.protobuf.MapField.newMapField(
              IdToStringDefaultEntryHolder.defaultEntry);
        }
        if (!idToString_.isMutable()) {
          idToString_ = idToString_.copy();
        }
        return idToString_;
      }

      public int getIdToStringCount() {
        return internalGetIdToString().getMap().size();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
       */

      public boolean containsIdToString(
          long key) {
        
        return internalGetIdToString().getMap().containsKey(key);
      }
      /**
       * Use {@link #getIdToStringMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, java.lang.String> getIdToString() {
        return getIdToStringMap();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
       */

      public java.util.Map<java.lang.Long, java.lang.String> getIdToStringMap() {
        return internalGetIdToString().getMap();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
       */

      public java.lang.String getIdToStringOrDefault(
          long key,
          java.lang.String defaultValue) {
        
        java.util.Map<java.lang.Long, java.lang.String> map =
            internalGetIdToString().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
       */

      public java.lang.String getIdToStringOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, java.lang.String> map =
            internalGetIdToString().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearIdToString() {
        internalGetMutableIdToString().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
       */

      public Builder removeIdToString(
          long key) {
        
        internalGetMutableIdToString().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, java.lang.String>
      getMutableIdToString() {
        return internalGetMutableIdToString().getMutableMap();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
       */
      public Builder putIdToString(
          long key,
          java.lang.String value) {
        
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableIdToString().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 2;</code>
       */

      public Builder putAllIdToString(
          java.util.Map<java.lang.Long, java.lang.String> values) {
        internalGetMutableIdToString().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.OpLogProto)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.OpLogProto)
    private static final tensorflow.tfprof.TfprofLog.OpLogProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.OpLogProto();
    }

    public static tensorflow.tfprof.TfprofLog.OpLogProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OpLogProto>
        PARSER = new com.google.protobuf.AbstractParser<OpLogProto>() {
      public OpLogProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new OpLogProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<OpLogProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OpLogProto> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.OpLogProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProfileProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.ProfileProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */
    int getNodesCount();
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */
    boolean containsNodes(
        long key);
    /**
     * Use {@link #getNodesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
    getNodes();
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */
    java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
    getNodesMap();
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */

    tensorflow.tfprof.TfprofLog.ProfileNode getNodesOrDefault(
        long key,
        tensorflow.tfprof.TfprofLog.ProfileNode defaultValue);
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */

    tensorflow.tfprof.TfprofLog.ProfileNode getNodesOrThrow(
        long key);

    /**
     * <pre>
     * Whether or not has code traces.
     * </pre>
     *
     * <code>bool has_trace = 2;</code>
     */
    boolean getHasTrace();

    /**
     * <pre>
     * Whether or not the TF device tracer fails to return accelerator
     * information (which could lead to 0 accelerator execution time).
     * </pre>
     *
     * <code>bool miss_accelerator_stream = 5;</code>
     */
    boolean getMissAcceleratorStream();

    /**
     * <pre>
     * Traced steps.
     * </pre>
     *
     * <code>repeated int64 steps = 3;</code>
     */
    java.util.List<java.lang.Long> getStepsList();
    /**
     * <pre>
     * Traced steps.
     * </pre>
     *
     * <code>repeated int64 steps = 3;</code>
     */
    int getStepsCount();
    /**
     * <pre>
     * Traced steps.
     * </pre>
     *
     * <code>repeated int64 steps = 3;</code>
     */
    long getSteps(int index);

    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */
    int getIdToStringCount();
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */
    boolean containsIdToString(
        long key);
    /**
     * Use {@link #getIdToStringMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, java.lang.String>
    getIdToString();
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */
    java.util.Map<java.lang.Long, java.lang.String>
    getIdToStringMap();
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */

    java.lang.String getIdToStringOrDefault(
        long key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */

    java.lang.String getIdToStringOrThrow(
        long key);
  }
  /**
   * <pre>
   * A proto representation of the profiler's profile.
   * It allows serialization, shipping around and deserialization of the profiles.
   * Please don't depend on the internals of the profile proto.
   * </pre>
   *
   * Protobuf type {@code tensorflow.tfprof.ProfileProto}
   */
  public  static final class ProfileProto extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.ProfileProto)
      ProfileProtoOrBuilder {
    // Use ProfileProto.newBuilder() to construct.
    private ProfileProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProfileProto() {
      hasTrace_ = false;
      missAcceleratorStream_ = false;
      steps_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private ProfileProto(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                nodes_ = com.google.protobuf.MapField.newMapField(
                    NodesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
              nodes__ = input.readMessage(
                  NodesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              nodes_.getMutableMap().put(
                  nodes__.getKey(), nodes__.getValue());
              break;
            }
            case 16: {

              hasTrace_ = input.readBool();
              break;
            }
            case 24: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                steps_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000008;
              }
              steps_.add(input.readInt64());
              break;
            }
            case 26: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008) && input.getBytesUntilLimit() > 0) {
                steps_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000008;
              }
              while (input.getBytesUntilLimit() > 0) {
                steps_.add(input.readInt64());
              }
              input.popLimit(limit);
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                idToString_ = com.google.protobuf.MapField.newMapField(
                    IdToStringDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.Long, java.lang.String>
              idToString__ = input.readMessage(
                  IdToStringDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              idToString_.getMutableMap().put(
                  idToString__.getKey(), idToString__.getValue());
              break;
            }
            case 40: {

              missAcceleratorStream_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          steps_ = java.util.Collections.unmodifiableList(steps_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileProto_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetNodes();
        case 4:
          return internalGetIdToString();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.ProfileProto.class, tensorflow.tfprof.TfprofLog.ProfileProto.Builder.class);
    }

    private int bitField0_;
    public static final int NODES_FIELD_NUMBER = 1;
    private static final class NodesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileProto_NodesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  tensorflow.tfprof.TfprofLog.ProfileNode.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> nodes_;
    private com.google.protobuf.MapField<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
    internalGetNodes() {
      if (nodes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            NodesDefaultEntryHolder.defaultEntry);
      }
      return nodes_;
    }

    public int getNodesCount() {
      return internalGetNodes().getMap().size();
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */

    public boolean containsNodes(
        long key) {
      
      return internalGetNodes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getNodesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> getNodes() {
      return getNodesMap();
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */

    public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> getNodesMap() {
      return internalGetNodes().getMap();
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */

    public tensorflow.tfprof.TfprofLog.ProfileNode getNodesOrDefault(
        long key,
        tensorflow.tfprof.TfprofLog.ProfileNode defaultValue) {
      
      java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> map =
          internalGetNodes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
     */

    public tensorflow.tfprof.TfprofLog.ProfileNode getNodesOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> map =
          internalGetNodes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int HAS_TRACE_FIELD_NUMBER = 2;
    private boolean hasTrace_;
    /**
     * <pre>
     * Whether or not has code traces.
     * </pre>
     *
     * <code>bool has_trace = 2;</code>
     */
    public boolean getHasTrace() {
      return hasTrace_;
    }

    public static final int MISS_ACCELERATOR_STREAM_FIELD_NUMBER = 5;
    private boolean missAcceleratorStream_;
    /**
     * <pre>
     * Whether or not the TF device tracer fails to return accelerator
     * information (which could lead to 0 accelerator execution time).
     * </pre>
     *
     * <code>bool miss_accelerator_stream = 5;</code>
     */
    public boolean getMissAcceleratorStream() {
      return missAcceleratorStream_;
    }

    public static final int STEPS_FIELD_NUMBER = 3;
    private java.util.List<java.lang.Long> steps_;
    /**
     * <pre>
     * Traced steps.
     * </pre>
     *
     * <code>repeated int64 steps = 3;</code>
     */
    public java.util.List<java.lang.Long>
        getStepsList() {
      return steps_;
    }
    /**
     * <pre>
     * Traced steps.
     * </pre>
     *
     * <code>repeated int64 steps = 3;</code>
     */
    public int getStepsCount() {
      return steps_.size();
    }
    /**
     * <pre>
     * Traced steps.
     * </pre>
     *
     * <code>repeated int64 steps = 3;</code>
     */
    public long getSteps(int index) {
      return steps_.get(index);
    }
    private int stepsMemoizedSerializedSize = -1;

    public static final int ID_TO_STRING_FIELD_NUMBER = 4;
    private static final class IdToStringDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Long, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Long, java.lang.String>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileProto_IdToStringEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.Long, java.lang.String> idToString_;
    private com.google.protobuf.MapField<java.lang.Long, java.lang.String>
    internalGetIdToString() {
      if (idToString_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            IdToStringDefaultEntryHolder.defaultEntry);
      }
      return idToString_;
    }

    public int getIdToStringCount() {
      return internalGetIdToString().getMap().size();
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */

    public boolean containsIdToString(
        long key) {
      
      return internalGetIdToString().getMap().containsKey(key);
    }
    /**
     * Use {@link #getIdToStringMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, java.lang.String> getIdToString() {
      return getIdToStringMap();
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */

    public java.util.Map<java.lang.Long, java.lang.String> getIdToStringMap() {
      return internalGetIdToString().getMap();
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */

    public java.lang.String getIdToStringOrDefault(
        long key,
        java.lang.String defaultValue) {
      
      java.util.Map<java.lang.Long, java.lang.String> map =
          internalGetIdToString().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Maps from id of CodeDef file,function,line to its string
     * In the future can also map other id of other fields to string.
     * </pre>
     *
     * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
     */

    public java.lang.String getIdToStringOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, java.lang.String> map =
          internalGetIdToString().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      com.google.protobuf.GeneratedMessageV3
        .serializeLongMapTo(
          output,
          internalGetNodes(),
          NodesDefaultEntryHolder.defaultEntry,
          1);
      if (hasTrace_ != false) {
        output.writeBool(2, hasTrace_);
      }
      if (getStepsList().size() > 0) {
        output.writeUInt32NoTag(26);
        output.writeUInt32NoTag(stepsMemoizedSerializedSize);
      }
      for (int i = 0; i < steps_.size(); i++) {
        output.writeInt64NoTag(steps_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeLongMapTo(
          output,
          internalGetIdToString(),
          IdToStringDefaultEntryHolder.defaultEntry,
          4);
      if (missAcceleratorStream_ != false) {
        output.writeBool(5, missAcceleratorStream_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> entry
           : internalGetNodes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
        nodes__ = NodesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, nodes__);
      }
      if (hasTrace_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, hasTrace_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < steps_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(steps_.get(i));
        }
        size += dataSize;
        if (!getStepsList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        stepsMemoizedSerializedSize = dataSize;
      }
      for (java.util.Map.Entry<java.lang.Long, java.lang.String> entry
           : internalGetIdToString().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Long, java.lang.String>
        idToString__ = IdToStringDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, idToString__);
      }
      if (missAcceleratorStream_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, missAcceleratorStream_);
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.ProfileProto)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.ProfileProto other = (tensorflow.tfprof.TfprofLog.ProfileProto) obj;

      boolean result = true;
      result = result && internalGetNodes().equals(
          other.internalGetNodes());
      result = result && (getHasTrace()
          == other.getHasTrace());
      result = result && (getMissAcceleratorStream()
          == other.getMissAcceleratorStream());
      result = result && getStepsList()
          .equals(other.getStepsList());
      result = result && internalGetIdToString().equals(
          other.internalGetIdToString());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetNodes().getMap().isEmpty()) {
        hash = (37 * hash) + NODES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetNodes().hashCode();
      }
      hash = (37 * hash) + HAS_TRACE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getHasTrace());
      hash = (37 * hash) + MISS_ACCELERATOR_STREAM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getMissAcceleratorStream());
      if (getStepsCount() > 0) {
        hash = (37 * hash) + STEPS_FIELD_NUMBER;
        hash = (53 * hash) + getStepsList().hashCode();
      }
      if (!internalGetIdToString().getMap().isEmpty()) {
        hash = (37 * hash) + ID_TO_STRING_FIELD_NUMBER;
        hash = (53 * hash) + internalGetIdToString().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.ProfileProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A proto representation of the profiler's profile.
     * It allows serialization, shipping around and deserialization of the profiles.
     * Please don't depend on the internals of the profile proto.
     * </pre>
     *
     * Protobuf type {@code tensorflow.tfprof.ProfileProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.ProfileProto)
        tensorflow.tfprof.TfprofLog.ProfileProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileProto_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetNodes();
          case 4:
            return internalGetIdToString();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableNodes();
          case 4:
            return internalGetMutableIdToString();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.ProfileProto.class, tensorflow.tfprof.TfprofLog.ProfileProto.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.ProfileProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        internalGetMutableNodes().clear();
        hasTrace_ = false;

        missAcceleratorStream_ = false;

        steps_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        internalGetMutableIdToString().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileProto_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.ProfileProto getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.ProfileProto.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.ProfileProto build() {
        tensorflow.tfprof.TfprofLog.ProfileProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.ProfileProto buildPartial() {
        tensorflow.tfprof.TfprofLog.ProfileProto result = new tensorflow.tfprof.TfprofLog.ProfileProto(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.nodes_ = internalGetNodes();
        result.nodes_.makeImmutable();
        result.hasTrace_ = hasTrace_;
        result.missAcceleratorStream_ = missAcceleratorStream_;
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          steps_ = java.util.Collections.unmodifiableList(steps_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.steps_ = steps_;
        result.idToString_ = internalGetIdToString();
        result.idToString_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.ProfileProto) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.ProfileProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.ProfileProto other) {
        if (other == tensorflow.tfprof.TfprofLog.ProfileProto.getDefaultInstance()) return this;
        internalGetMutableNodes().mergeFrom(
            other.internalGetNodes());
        if (other.getHasTrace() != false) {
          setHasTrace(other.getHasTrace());
        }
        if (other.getMissAcceleratorStream() != false) {
          setMissAcceleratorStream(other.getMissAcceleratorStream());
        }
        if (!other.steps_.isEmpty()) {
          if (steps_.isEmpty()) {
            steps_ = other.steps_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureStepsIsMutable();
            steps_.addAll(other.steps_);
          }
          onChanged();
        }
        internalGetMutableIdToString().mergeFrom(
            other.internalGetIdToString());
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.ProfileProto parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.ProfileProto) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> nodes_;
      private com.google.protobuf.MapField<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
      internalGetNodes() {
        if (nodes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              NodesDefaultEntryHolder.defaultEntry);
        }
        return nodes_;
      }
      private com.google.protobuf.MapField<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
      internalGetMutableNodes() {
        onChanged();;
        if (nodes_ == null) {
          nodes_ = com.google.protobuf.MapField.newMapField(
              NodesDefaultEntryHolder.defaultEntry);
        }
        if (!nodes_.isMutable()) {
          nodes_ = nodes_.copy();
        }
        return nodes_;
      }

      public int getNodesCount() {
        return internalGetNodes().getMap().size();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
       */

      public boolean containsNodes(
          long key) {
        
        return internalGetNodes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getNodesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> getNodes() {
        return getNodesMap();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
       */

      public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> getNodesMap() {
        return internalGetNodes().getMap();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
       */

      public tensorflow.tfprof.TfprofLog.ProfileNode getNodesOrDefault(
          long key,
          tensorflow.tfprof.TfprofLog.ProfileNode defaultValue) {
        
        java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> map =
            internalGetNodes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
       */

      public tensorflow.tfprof.TfprofLog.ProfileNode getNodesOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> map =
            internalGetNodes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearNodes() {
        internalGetMutableNodes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
       */

      public Builder removeNodes(
          long key) {
        
        internalGetMutableNodes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode>
      getMutableNodes() {
        return internalGetMutableNodes().getMutableMap();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
       */
      public Builder putNodes(
          long key,
          tensorflow.tfprof.TfprofLog.ProfileNode value) {
        
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableNodes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ProfileNode&gt; nodes = 1;</code>
       */

      public Builder putAllNodes(
          java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ProfileNode> values) {
        internalGetMutableNodes().getMutableMap()
            .putAll(values);
        return this;
      }

      private boolean hasTrace_ ;
      /**
       * <pre>
       * Whether or not has code traces.
       * </pre>
       *
       * <code>bool has_trace = 2;</code>
       */
      public boolean getHasTrace() {
        return hasTrace_;
      }
      /**
       * <pre>
       * Whether or not has code traces.
       * </pre>
       *
       * <code>bool has_trace = 2;</code>
       */
      public Builder setHasTrace(boolean value) {
        
        hasTrace_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether or not has code traces.
       * </pre>
       *
       * <code>bool has_trace = 2;</code>
       */
      public Builder clearHasTrace() {
        
        hasTrace_ = false;
        onChanged();
        return this;
      }

      private boolean missAcceleratorStream_ ;
      /**
       * <pre>
       * Whether or not the TF device tracer fails to return accelerator
       * information (which could lead to 0 accelerator execution time).
       * </pre>
       *
       * <code>bool miss_accelerator_stream = 5;</code>
       */
      public boolean getMissAcceleratorStream() {
        return missAcceleratorStream_;
      }
      /**
       * <pre>
       * Whether or not the TF device tracer fails to return accelerator
       * information (which could lead to 0 accelerator execution time).
       * </pre>
       *
       * <code>bool miss_accelerator_stream = 5;</code>
       */
      public Builder setMissAcceleratorStream(boolean value) {
        
        missAcceleratorStream_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether or not the TF device tracer fails to return accelerator
       * information (which could lead to 0 accelerator execution time).
       * </pre>
       *
       * <code>bool miss_accelerator_stream = 5;</code>
       */
      public Builder clearMissAcceleratorStream() {
        
        missAcceleratorStream_ = false;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Long> steps_ = java.util.Collections.emptyList();
      private void ensureStepsIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          steps_ = new java.util.ArrayList<java.lang.Long>(steps_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <pre>
       * Traced steps.
       * </pre>
       *
       * <code>repeated int64 steps = 3;</code>
       */
      public java.util.List<java.lang.Long>
          getStepsList() {
        return java.util.Collections.unmodifiableList(steps_);
      }
      /**
       * <pre>
       * Traced steps.
       * </pre>
       *
       * <code>repeated int64 steps = 3;</code>
       */
      public int getStepsCount() {
        return steps_.size();
      }
      /**
       * <pre>
       * Traced steps.
       * </pre>
       *
       * <code>repeated int64 steps = 3;</code>
       */
      public long getSteps(int index) {
        return steps_.get(index);
      }
      /**
       * <pre>
       * Traced steps.
       * </pre>
       *
       * <code>repeated int64 steps = 3;</code>
       */
      public Builder setSteps(
          int index, long value) {
        ensureStepsIsMutable();
        steps_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Traced steps.
       * </pre>
       *
       * <code>repeated int64 steps = 3;</code>
       */
      public Builder addSteps(long value) {
        ensureStepsIsMutable();
        steps_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Traced steps.
       * </pre>
       *
       * <code>repeated int64 steps = 3;</code>
       */
      public Builder addAllSteps(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureStepsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, steps_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Traced steps.
       * </pre>
       *
       * <code>repeated int64 steps = 3;</code>
       */
      public Builder clearSteps() {
        steps_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Long, java.lang.String> idToString_;
      private com.google.protobuf.MapField<java.lang.Long, java.lang.String>
      internalGetIdToString() {
        if (idToString_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              IdToStringDefaultEntryHolder.defaultEntry);
        }
        return idToString_;
      }
      private com.google.protobuf.MapField<java.lang.Long, java.lang.String>
      internalGetMutableIdToString() {
        onChanged();;
        if (idToString_ == null) {
          idToString_ = com.google.protobuf.MapField.newMapField(
              IdToStringDefaultEntryHolder.defaultEntry);
        }
        if (!idToString_.isMutable()) {
          idToString_ = idToString_.copy();
        }
        return idToString_;
      }

      public int getIdToStringCount() {
        return internalGetIdToString().getMap().size();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
       */

      public boolean containsIdToString(
          long key) {
        
        return internalGetIdToString().getMap().containsKey(key);
      }
      /**
       * Use {@link #getIdToStringMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, java.lang.String> getIdToString() {
        return getIdToStringMap();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
       */

      public java.util.Map<java.lang.Long, java.lang.String> getIdToStringMap() {
        return internalGetIdToString().getMap();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
       */

      public java.lang.String getIdToStringOrDefault(
          long key,
          java.lang.String defaultValue) {
        
        java.util.Map<java.lang.Long, java.lang.String> map =
            internalGetIdToString().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
       */

      public java.lang.String getIdToStringOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, java.lang.String> map =
            internalGetIdToString().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearIdToString() {
        internalGetMutableIdToString().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
       */

      public Builder removeIdToString(
          long key) {
        
        internalGetMutableIdToString().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, java.lang.String>
      getMutableIdToString() {
        return internalGetMutableIdToString().getMutableMap();
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
       */
      public Builder putIdToString(
          long key,
          java.lang.String value) {
        
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableIdToString().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Maps from id of CodeDef file,function,line to its string
       * In the future can also map other id of other fields to string.
       * </pre>
       *
       * <code>map&lt;int64, string&gt; id_to_string = 4;</code>
       */

      public Builder putAllIdToString(
          java.util.Map<java.lang.Long, java.lang.String> values) {
        internalGetMutableIdToString().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.ProfileProto)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.ProfileProto)
    private static final tensorflow.tfprof.TfprofLog.ProfileProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.ProfileProto();
    }

    public static tensorflow.tfprof.TfprofLog.ProfileProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProfileProto>
        PARSER = new com.google.protobuf.AbstractParser<ProfileProto>() {
      public ProfileProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new ProfileProto(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ProfileProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProfileProto> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.ProfileProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProfileNodeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.ProfileNode)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * graph node name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * graph node name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * graph operation type.
     * </pre>
     *
     * <code>string op = 9;</code>
     */
    java.lang.String getOp();
    /**
     * <pre>
     * graph operation type.
     * </pre>
     *
     * <code>string op = 9;</code>
     */
    com.google.protobuf.ByteString
        getOpBytes();

    /**
     * <pre>
     * A unique id for the node.
     * </pre>
     *
     * <code>int64 id = 13;</code>
     */
    long getId();

    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */
    int getInputsCount();
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */
    boolean containsInputs(
        int key);
    /**
     * Use {@link #getInputsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, java.lang.Long>
    getInputs();
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */
    java.util.Map<java.lang.Integer, java.lang.Long>
    getInputsMap();
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */

    long getInputsOrDefault(
        int key,
        long defaultValue);
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */

    long getInputsOrThrow(
        int key);

    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */
    int getInputShapesCount();
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */
    boolean containsInputShapes(
        int key);
    /**
     * Use {@link #getInputShapesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
    getInputShapes();
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */
    java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
    getInputShapesMap();
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */

    tensorflow.tfprof.TfprofLog.Tuple getInputShapesOrDefault(
        int key,
        tensorflow.tfprof.TfprofLog.Tuple defaultValue);
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */

    tensorflow.tfprof.TfprofLog.Tuple getInputShapesOrThrow(
        int key);

    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */
    int getOutputsCount();
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */
    boolean containsOutputs(
        int key);
    /**
     * Use {@link #getOutputsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, java.lang.Long>
    getOutputs();
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */
    java.util.Map<java.lang.Integer, java.lang.Long>
    getOutputsMap();
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */

    long getOutputsOrDefault(
        int key,
        long defaultValue);
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */

    long getOutputsOrThrow(
        int key);

    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */
    int getOutputShapesCount();
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */
    boolean containsOutputShapes(
        int key);
    /**
     * Use {@link #getOutputShapesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
    getOutputShapes();
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */
    java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
    getOutputShapesMap();
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */

    tensorflow.tfprof.TfprofLog.Tuple getOutputShapesOrDefault(
        int key,
        tensorflow.tfprof.TfprofLog.Tuple defaultValue);
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */

    tensorflow.tfprof.TfprofLog.Tuple getOutputShapesOrThrow(
        int key);

    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */
    int getSrcOutputIndexCount();
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */
    boolean containsSrcOutputIndex(
        long key);
    /**
     * Use {@link #getSrcOutputIndexMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, java.lang.Integer>
    getSrcOutputIndex();
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */
    java.util.Map<java.lang.Long, java.lang.Integer>
    getSrcOutputIndexMap();
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */

    int getSrcOutputIndexOrDefault(
        long key,
        int defaultValue);
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */

    int getSrcOutputIndexOrThrow(
        long key);

    /**
     * <code>repeated int64 shape = 4;</code>
     */
    java.util.List<java.lang.Long> getShapeList();
    /**
     * <code>repeated int64 shape = 4;</code>
     */
    int getShapeCount();
    /**
     * <code>repeated int64 shape = 4;</code>
     */
    long getShape(int index);

    /**
     * <code>repeated string op_types = 5;</code>
     */
    java.util.List<java.lang.String>
        getOpTypesList();
    /**
     * <code>repeated string op_types = 5;</code>
     */
    int getOpTypesCount();
    /**
     * <code>repeated string op_types = 5;</code>
     */
    java.lang.String getOpTypes(int index);
    /**
     * <code>repeated string op_types = 5;</code>
     */
    com.google.protobuf.ByteString
        getOpTypesBytes(int index);

    /**
     * <code>string canonical_device = 6;</code>
     */
    java.lang.String getCanonicalDevice();
    /**
     * <code>string canonical_device = 6;</code>
     */
    com.google.protobuf.ByteString
        getCanonicalDeviceBytes();

    /**
     * <code>string host_device = 7;</code>
     */
    java.lang.String getHostDevice();
    /**
     * <code>string host_device = 7;</code>
     */
    com.google.protobuf.ByteString
        getHostDeviceBytes();

    /**
     * <code>int64 float_ops = 8;</code>
     */
    long getFloatOps();

    /**
     * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
     */
    boolean hasTrace();
    /**
     * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
     */
    tensorflow.tfprof.TfprofLog.CodeDef getTrace();
    /**
     * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
     */
    tensorflow.tfprof.TfprofLog.CodeDefOrBuilder getTraceOrBuilder();

    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */
    int getAttrsCount();
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */
    boolean containsAttrs(
        java.lang.String key);
    /**
     * Use {@link #getAttrsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue>
    getAttrs();
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */
    java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue>
    getAttrsMap();
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */

    org.tensorflow.framework.AttrValue getAttrsOrDefault(
        java.lang.String key,
        org.tensorflow.framework.AttrValue defaultValue);
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */

    org.tensorflow.framework.AttrValue getAttrsOrThrow(
        java.lang.String key);

    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */
    int getExecsCount();
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */
    boolean containsExecs(
        long key);
    /**
     * Use {@link #getExecsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
    getExecs();
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */
    java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
    getExecsMap();
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */

    tensorflow.tfprof.TfprofLog.ExecProfile getExecsOrDefault(
        long key,
        tensorflow.tfprof.TfprofLog.ExecProfile defaultValue);
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */

    tensorflow.tfprof.TfprofLog.ExecProfile getExecsOrThrow(
        long key);
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.ProfileNode}
   */
  public  static final class ProfileNode extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.ProfileNode)
      ProfileNodeOrBuilder {
    // Use ProfileNode.newBuilder() to construct.
    private ProfileNode(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProfileNode() {
      name_ = "";
      op_ = "";
      id_ = 0L;
      shape_ = java.util.Collections.emptyList();
      opTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      canonicalDevice_ = "";
      hostDevice_ = "";
      floatOps_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private ProfileNode(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                inputs_ = com.google.protobuf.MapField.newMapField(
                    InputsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.Integer, java.lang.Long>
              inputs__ = input.readMessage(
                  InputsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              inputs_.getMutableMap().put(
                  inputs__.getKey(), inputs__.getValue());
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                outputs_ = com.google.protobuf.MapField.newMapField(
                    OutputsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000020;
              }
              com.google.protobuf.MapEntry<java.lang.Integer, java.lang.Long>
              outputs__ = input.readMessage(
                  OutputsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              outputs_.getMutableMap().put(
                  outputs__.getKey(), outputs__.getValue());
              break;
            }
            case 32: {
              if (!((mutable_bitField0_ & 0x00000100) == 0x00000100)) {
                shape_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000100;
              }
              shape_.add(input.readInt64());
              break;
            }
            case 34: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000100) == 0x00000100) && input.getBytesUntilLimit() > 0) {
                shape_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000100;
              }
              while (input.getBytesUntilLimit() > 0) {
                shape_.add(input.readInt64());
              }
              input.popLimit(limit);
              break;
            }
            case 42: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
                opTypes_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000200;
              }
              opTypes_.add(s);
              break;
            }
            case 50: {
              java.lang.String s = input.readStringRequireUtf8();

              canonicalDevice_ = s;
              break;
            }
            case 58: {
              java.lang.String s = input.readStringRequireUtf8();

              hostDevice_ = s;
              break;
            }
            case 64: {

              floatOps_ = input.readInt64();
              break;
            }
            case 74: {
              java.lang.String s = input.readStringRequireUtf8();

              op_ = s;
              break;
            }
            case 82: {
              tensorflow.tfprof.TfprofLog.CodeDef.Builder subBuilder = null;
              if (trace_ != null) {
                subBuilder = trace_.toBuilder();
              }
              trace_ = input.readMessage(tensorflow.tfprof.TfprofLog.CodeDef.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(trace_);
                trace_ = subBuilder.buildPartial();
              }

              break;
            }
            case 90: {
              if (!((mutable_bitField0_ & 0x00004000) == 0x00004000)) {
                attrs_ = com.google.protobuf.MapField.newMapField(
                    AttrsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00004000;
              }
              com.google.protobuf.MapEntry<java.lang.String, org.tensorflow.framework.AttrValue>
              attrs__ = input.readMessage(
                  AttrsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              attrs_.getMutableMap().put(
                  attrs__.getKey(), attrs__.getValue());
              break;
            }
            case 98: {
              if (!((mutable_bitField0_ & 0x00008000) == 0x00008000)) {
                execs_ = com.google.protobuf.MapField.newMapField(
                    ExecsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00008000;
              }
              com.google.protobuf.MapEntry<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
              execs__ = input.readMessage(
                  ExecsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              execs_.getMutableMap().put(
                  execs__.getKey(), execs__.getValue());
              break;
            }
            case 104: {

              id_ = input.readInt64();
              break;
            }
            case 114: {
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                srcOutputIndex_ = com.google.protobuf.MapField.newMapField(
                    SrcOutputIndexDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000080;
              }
              com.google.protobuf.MapEntry<java.lang.Long, java.lang.Integer>
              srcOutputIndex__ = input.readMessage(
                  SrcOutputIndexDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              srcOutputIndex_.getMutableMap().put(
                  srcOutputIndex__.getKey(), srcOutputIndex__.getValue());
              break;
            }
            case 122: {
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                outputShapes_ = com.google.protobuf.MapField.newMapField(
                    OutputShapesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000040;
              }
              com.google.protobuf.MapEntry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
              outputShapes__ = input.readMessage(
                  OutputShapesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              outputShapes_.getMutableMap().put(
                  outputShapes__.getKey(), outputShapes__.getValue());
              break;
            }
            case 130: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                inputShapes_ = com.google.protobuf.MapField.newMapField(
                    InputShapesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
              inputShapes__ = input.readMessage(
                  InputShapesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              inputShapes_.getMutableMap().put(
                  inputShapes__.getKey(), inputShapes__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000100) == 0x00000100)) {
          shape_ = java.util.Collections.unmodifiableList(shape_);
        }
        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
          opTypes_ = opTypes_.getUnmodifiableView();
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetInputs();
        case 16:
          return internalGetInputShapes();
        case 3:
          return internalGetOutputs();
        case 15:
          return internalGetOutputShapes();
        case 14:
          return internalGetSrcOutputIndex();
        case 11:
          return internalGetAttrs();
        case 12:
          return internalGetExecs();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.ProfileNode.class, tensorflow.tfprof.TfprofLog.ProfileNode.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * graph node name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * graph node name.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OP_FIELD_NUMBER = 9;
    private volatile java.lang.Object op_;
    /**
     * <pre>
     * graph operation type.
     * </pre>
     *
     * <code>string op = 9;</code>
     */
    public java.lang.String getOp() {
      java.lang.Object ref = op_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        op_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * graph operation type.
     * </pre>
     *
     * <code>string op = 9;</code>
     */
    public com.google.protobuf.ByteString
        getOpBytes() {
      java.lang.Object ref = op_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        op_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ID_FIELD_NUMBER = 13;
    private long id_;
    /**
     * <pre>
     * A unique id for the node.
     * </pre>
     *
     * <code>int64 id = 13;</code>
     */
    public long getId() {
      return id_;
    }

    public static final int INPUTS_FIELD_NUMBER = 2;
    private static final class InputsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Integer, java.lang.Long> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Integer, java.lang.Long>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_InputsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L);
    }
    private com.google.protobuf.MapField<
        java.lang.Integer, java.lang.Long> inputs_;
    private com.google.protobuf.MapField<java.lang.Integer, java.lang.Long>
    internalGetInputs() {
      if (inputs_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            InputsDefaultEntryHolder.defaultEntry);
      }
      return inputs_;
    }

    public int getInputsCount() {
      return internalGetInputs().getMap().size();
    }
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */

    public boolean containsInputs(
        int key) {
      
      return internalGetInputs().getMap().containsKey(key);
    }
    /**
     * Use {@link #getInputsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.Long> getInputs() {
      return getInputsMap();
    }
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */

    public java.util.Map<java.lang.Integer, java.lang.Long> getInputsMap() {
      return internalGetInputs().getMap();
    }
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */

    public long getInputsOrDefault(
        int key,
        long defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.Long> map =
          internalGetInputs().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, int64&gt; inputs = 2;</code>
     */

    public long getInputsOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.Long> map =
          internalGetInputs().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int INPUT_SHAPES_FIELD_NUMBER = 16;
    private static final class InputShapesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_InputShapesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  tensorflow.tfprof.TfprofLog.Tuple.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> inputShapes_;
    private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
    internalGetInputShapes() {
      if (inputShapes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            InputShapesDefaultEntryHolder.defaultEntry);
      }
      return inputShapes_;
    }

    public int getInputShapesCount() {
      return internalGetInputShapes().getMap().size();
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */

    public boolean containsInputShapes(
        int key) {
      
      return internalGetInputShapes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getInputShapesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getInputShapes() {
      return getInputShapesMap();
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */

    public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getInputShapesMap() {
      return internalGetInputShapes().getMap();
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */

    public tensorflow.tfprof.TfprofLog.Tuple getInputShapesOrDefault(
        int key,
        tensorflow.tfprof.TfprofLog.Tuple defaultValue) {
      
      java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
          internalGetInputShapes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
     */

    public tensorflow.tfprof.TfprofLog.Tuple getInputShapesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
          internalGetInputShapes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int OUTPUTS_FIELD_NUMBER = 3;
    private static final class OutputsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Integer, java.lang.Long> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Integer, java.lang.Long>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_OutputsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L);
    }
    private com.google.protobuf.MapField<
        java.lang.Integer, java.lang.Long> outputs_;
    private com.google.protobuf.MapField<java.lang.Integer, java.lang.Long>
    internalGetOutputs() {
      if (outputs_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            OutputsDefaultEntryHolder.defaultEntry);
      }
      return outputs_;
    }

    public int getOutputsCount() {
      return internalGetOutputs().getMap().size();
    }
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */

    public boolean containsOutputs(
        int key) {
      
      return internalGetOutputs().getMap().containsKey(key);
    }
    /**
     * Use {@link #getOutputsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, java.lang.Long> getOutputs() {
      return getOutputsMap();
    }
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */

    public java.util.Map<java.lang.Integer, java.lang.Long> getOutputsMap() {
      return internalGetOutputs().getMap();
    }
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */

    public long getOutputsOrDefault(
        int key,
        long defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.Long> map =
          internalGetOutputs().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, int64&gt; outputs = 3;</code>
     */

    public long getOutputsOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.Long> map =
          internalGetOutputs().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int OUTPUT_SHAPES_FIELD_NUMBER = 15;
    private static final class OutputShapesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_OutputShapesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  tensorflow.tfprof.TfprofLog.Tuple.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> outputShapes_;
    private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
    internalGetOutputShapes() {
      if (outputShapes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            OutputShapesDefaultEntryHolder.defaultEntry);
      }
      return outputShapes_;
    }

    public int getOutputShapesCount() {
      return internalGetOutputShapes().getMap().size();
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */

    public boolean containsOutputShapes(
        int key) {
      
      return internalGetOutputShapes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getOutputShapesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getOutputShapes() {
      return getOutputShapesMap();
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */

    public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getOutputShapesMap() {
      return internalGetOutputShapes().getMap();
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */

    public tensorflow.tfprof.TfprofLog.Tuple getOutputShapesOrDefault(
        int key,
        tensorflow.tfprof.TfprofLog.Tuple defaultValue) {
      
      java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
          internalGetOutputShapes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
     */

    public tensorflow.tfprof.TfprofLog.Tuple getOutputShapesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
          internalGetOutputShapes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int SRC_OUTPUT_INDEX_FIELD_NUMBER = 14;
    private static final class SrcOutputIndexDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Long, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Long, java.lang.Integer>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_SrcOutputIndexEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0);
    }
    private com.google.protobuf.MapField<
        java.lang.Long, java.lang.Integer> srcOutputIndex_;
    private com.google.protobuf.MapField<java.lang.Long, java.lang.Integer>
    internalGetSrcOutputIndex() {
      if (srcOutputIndex_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SrcOutputIndexDefaultEntryHolder.defaultEntry);
      }
      return srcOutputIndex_;
    }

    public int getSrcOutputIndexCount() {
      return internalGetSrcOutputIndex().getMap().size();
    }
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */

    public boolean containsSrcOutputIndex(
        long key) {
      
      return internalGetSrcOutputIndex().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSrcOutputIndexMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, java.lang.Integer> getSrcOutputIndex() {
      return getSrcOutputIndexMap();
    }
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */

    public java.util.Map<java.lang.Long, java.lang.Integer> getSrcOutputIndexMap() {
      return internalGetSrcOutputIndex().getMap();
    }
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */

    public int getSrcOutputIndexOrDefault(
        long key,
        int defaultValue) {
      
      java.util.Map<java.lang.Long, java.lang.Integer> map =
          internalGetSrcOutputIndex().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * A map from source node id to its output index to current node.
     * </pre>
     *
     * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
     */

    public int getSrcOutputIndexOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, java.lang.Integer> map =
          internalGetSrcOutputIndex().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int SHAPE_FIELD_NUMBER = 4;
    private java.util.List<java.lang.Long> shape_;
    /**
     * <code>repeated int64 shape = 4;</code>
     */
    public java.util.List<java.lang.Long>
        getShapeList() {
      return shape_;
    }
    /**
     * <code>repeated int64 shape = 4;</code>
     */
    public int getShapeCount() {
      return shape_.size();
    }
    /**
     * <code>repeated int64 shape = 4;</code>
     */
    public long getShape(int index) {
      return shape_.get(index);
    }
    private int shapeMemoizedSerializedSize = -1;

    public static final int OP_TYPES_FIELD_NUMBER = 5;
    private com.google.protobuf.LazyStringList opTypes_;
    /**
     * <code>repeated string op_types = 5;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getOpTypesList() {
      return opTypes_;
    }
    /**
     * <code>repeated string op_types = 5;</code>
     */
    public int getOpTypesCount() {
      return opTypes_.size();
    }
    /**
     * <code>repeated string op_types = 5;</code>
     */
    public java.lang.String getOpTypes(int index) {
      return opTypes_.get(index);
    }
    /**
     * <code>repeated string op_types = 5;</code>
     */
    public com.google.protobuf.ByteString
        getOpTypesBytes(int index) {
      return opTypes_.getByteString(index);
    }

    public static final int CANONICAL_DEVICE_FIELD_NUMBER = 6;
    private volatile java.lang.Object canonicalDevice_;
    /**
     * <code>string canonical_device = 6;</code>
     */
    public java.lang.String getCanonicalDevice() {
      java.lang.Object ref = canonicalDevice_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        canonicalDevice_ = s;
        return s;
      }
    }
    /**
     * <code>string canonical_device = 6;</code>
     */
    public com.google.protobuf.ByteString
        getCanonicalDeviceBytes() {
      java.lang.Object ref = canonicalDevice_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        canonicalDevice_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HOST_DEVICE_FIELD_NUMBER = 7;
    private volatile java.lang.Object hostDevice_;
    /**
     * <code>string host_device = 7;</code>
     */
    public java.lang.String getHostDevice() {
      java.lang.Object ref = hostDevice_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        hostDevice_ = s;
        return s;
      }
    }
    /**
     * <code>string host_device = 7;</code>
     */
    public com.google.protobuf.ByteString
        getHostDeviceBytes() {
      java.lang.Object ref = hostDevice_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        hostDevice_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FLOAT_OPS_FIELD_NUMBER = 8;
    private long floatOps_;
    /**
     * <code>int64 float_ops = 8;</code>
     */
    public long getFloatOps() {
      return floatOps_;
    }

    public static final int TRACE_FIELD_NUMBER = 10;
    private tensorflow.tfprof.TfprofLog.CodeDef trace_;
    /**
     * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
     */
    public boolean hasTrace() {
      return trace_ != null;
    }
    /**
     * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
     */
    public tensorflow.tfprof.TfprofLog.CodeDef getTrace() {
      return trace_ == null ? tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance() : trace_;
    }
    /**
     * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
     */
    public tensorflow.tfprof.TfprofLog.CodeDefOrBuilder getTraceOrBuilder() {
      return getTrace();
    }

    public static final int ATTRS_FIELD_NUMBER = 11;
    private static final class AttrsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, org.tensorflow.framework.AttrValue> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, org.tensorflow.framework.AttrValue>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_AttrsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  org.tensorflow.framework.AttrValue.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.String, org.tensorflow.framework.AttrValue> attrs_;
    private com.google.protobuf.MapField<java.lang.String, org.tensorflow.framework.AttrValue>
    internalGetAttrs() {
      if (attrs_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            AttrsDefaultEntryHolder.defaultEntry);
      }
      return attrs_;
    }

    public int getAttrsCount() {
      return internalGetAttrs().getMap().size();
    }
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */

    public boolean containsAttrs(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetAttrs().getMap().containsKey(key);
    }
    /**
     * Use {@link #getAttrsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> getAttrs() {
      return getAttrsMap();
    }
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */

    public java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> getAttrsMap() {
      return internalGetAttrs().getMap();
    }
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */

    public org.tensorflow.framework.AttrValue getAttrsOrDefault(
        java.lang.String key,
        org.tensorflow.framework.AttrValue defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> map =
          internalGetAttrs().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
     */

    public org.tensorflow.framework.AttrValue getAttrsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> map =
          internalGetAttrs().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int EXECS_FIELD_NUMBER = 12;
    private static final class ExecsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_ExecsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT64,
                  0L,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  tensorflow.tfprof.TfprofLog.ExecProfile.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> execs_;
    private com.google.protobuf.MapField<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
    internalGetExecs() {
      if (execs_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ExecsDefaultEntryHolder.defaultEntry);
      }
      return execs_;
    }

    public int getExecsCount() {
      return internalGetExecs().getMap().size();
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */

    public boolean containsExecs(
        long key) {
      
      return internalGetExecs().getMap().containsKey(key);
    }
    /**
     * Use {@link #getExecsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> getExecs() {
      return getExecsMap();
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */

    public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> getExecsMap() {
      return internalGetExecs().getMap();
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */

    public tensorflow.tfprof.TfprofLog.ExecProfile getExecsOrDefault(
        long key,
        tensorflow.tfprof.TfprofLog.ExecProfile defaultValue) {
      
      java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> map =
          internalGetExecs().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
     */

    public tensorflow.tfprof.TfprofLog.ExecProfile getExecsOrThrow(
        long key) {
      
      java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> map =
          internalGetExecs().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeIntegerMapTo(
          output,
          internalGetInputs(),
          InputsDefaultEntryHolder.defaultEntry,
          2);
      com.google.protobuf.GeneratedMessageV3
        .serializeIntegerMapTo(
          output,
          internalGetOutputs(),
          OutputsDefaultEntryHolder.defaultEntry,
          3);
      if (getShapeList().size() > 0) {
        output.writeUInt32NoTag(34);
        output.writeUInt32NoTag(shapeMemoizedSerializedSize);
      }
      for (int i = 0; i < shape_.size(); i++) {
        output.writeInt64NoTag(shape_.get(i));
      }
      for (int i = 0; i < opTypes_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, opTypes_.getRaw(i));
      }
      if (!getCanonicalDeviceBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, canonicalDevice_);
      }
      if (!getHostDeviceBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, hostDevice_);
      }
      if (floatOps_ != 0L) {
        output.writeInt64(8, floatOps_);
      }
      if (!getOpBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, op_);
      }
      if (trace_ != null) {
        output.writeMessage(10, getTrace());
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetAttrs(),
          AttrsDefaultEntryHolder.defaultEntry,
          11);
      com.google.protobuf.GeneratedMessageV3
        .serializeLongMapTo(
          output,
          internalGetExecs(),
          ExecsDefaultEntryHolder.defaultEntry,
          12);
      if (id_ != 0L) {
        output.writeInt64(13, id_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeLongMapTo(
          output,
          internalGetSrcOutputIndex(),
          SrcOutputIndexDefaultEntryHolder.defaultEntry,
          14);
      com.google.protobuf.GeneratedMessageV3
        .serializeIntegerMapTo(
          output,
          internalGetOutputShapes(),
          OutputShapesDefaultEntryHolder.defaultEntry,
          15);
      com.google.protobuf.GeneratedMessageV3
        .serializeIntegerMapTo(
          output,
          internalGetInputShapes(),
          InputShapesDefaultEntryHolder.defaultEntry,
          16);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      for (java.util.Map.Entry<java.lang.Integer, java.lang.Long> entry
           : internalGetInputs().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Integer, java.lang.Long>
        inputs__ = InputsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, inputs__);
      }
      for (java.util.Map.Entry<java.lang.Integer, java.lang.Long> entry
           : internalGetOutputs().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Integer, java.lang.Long>
        outputs__ = OutputsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, outputs__);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < shape_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(shape_.get(i));
        }
        size += dataSize;
        if (!getShapeList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        shapeMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < opTypes_.size(); i++) {
          dataSize += computeStringSizeNoTag(opTypes_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getOpTypesList().size();
      }
      if (!getCanonicalDeviceBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, canonicalDevice_);
      }
      if (!getHostDeviceBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, hostDevice_);
      }
      if (floatOps_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(8, floatOps_);
      }
      if (!getOpBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, op_);
      }
      if (trace_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getTrace());
      }
      for (java.util.Map.Entry<java.lang.String, org.tensorflow.framework.AttrValue> entry
           : internalGetAttrs().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, org.tensorflow.framework.AttrValue>
        attrs__ = AttrsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(11, attrs__);
      }
      for (java.util.Map.Entry<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> entry
           : internalGetExecs().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
        execs__ = ExecsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(12, execs__);
      }
      if (id_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(13, id_);
      }
      for (java.util.Map.Entry<java.lang.Long, java.lang.Integer> entry
           : internalGetSrcOutputIndex().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Long, java.lang.Integer>
        srcOutputIndex__ = SrcOutputIndexDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(14, srcOutputIndex__);
      }
      for (java.util.Map.Entry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> entry
           : internalGetOutputShapes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
        outputShapes__ = OutputShapesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(15, outputShapes__);
      }
      for (java.util.Map.Entry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> entry
           : internalGetInputShapes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
        inputShapes__ = InputShapesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(16, inputShapes__);
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.ProfileNode)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.ProfileNode other = (tensorflow.tfprof.TfprofLog.ProfileNode) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && getOp()
          .equals(other.getOp());
      result = result && (getId()
          == other.getId());
      result = result && internalGetInputs().equals(
          other.internalGetInputs());
      result = result && internalGetInputShapes().equals(
          other.internalGetInputShapes());
      result = result && internalGetOutputs().equals(
          other.internalGetOutputs());
      result = result && internalGetOutputShapes().equals(
          other.internalGetOutputShapes());
      result = result && internalGetSrcOutputIndex().equals(
          other.internalGetSrcOutputIndex());
      result = result && getShapeList()
          .equals(other.getShapeList());
      result = result && getOpTypesList()
          .equals(other.getOpTypesList());
      result = result && getCanonicalDevice()
          .equals(other.getCanonicalDevice());
      result = result && getHostDevice()
          .equals(other.getHostDevice());
      result = result && (getFloatOps()
          == other.getFloatOps());
      result = result && (hasTrace() == other.hasTrace());
      if (hasTrace()) {
        result = result && getTrace()
            .equals(other.getTrace());
      }
      result = result && internalGetAttrs().equals(
          other.internalGetAttrs());
      result = result && internalGetExecs().equals(
          other.internalGetExecs());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + OP_FIELD_NUMBER;
      hash = (53 * hash) + getOp().hashCode();
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getId());
      if (!internalGetInputs().getMap().isEmpty()) {
        hash = (37 * hash) + INPUTS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetInputs().hashCode();
      }
      if (!internalGetInputShapes().getMap().isEmpty()) {
        hash = (37 * hash) + INPUT_SHAPES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetInputShapes().hashCode();
      }
      if (!internalGetOutputs().getMap().isEmpty()) {
        hash = (37 * hash) + OUTPUTS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetOutputs().hashCode();
      }
      if (!internalGetOutputShapes().getMap().isEmpty()) {
        hash = (37 * hash) + OUTPUT_SHAPES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetOutputShapes().hashCode();
      }
      if (!internalGetSrcOutputIndex().getMap().isEmpty()) {
        hash = (37 * hash) + SRC_OUTPUT_INDEX_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSrcOutputIndex().hashCode();
      }
      if (getShapeCount() > 0) {
        hash = (37 * hash) + SHAPE_FIELD_NUMBER;
        hash = (53 * hash) + getShapeList().hashCode();
      }
      if (getOpTypesCount() > 0) {
        hash = (37 * hash) + OP_TYPES_FIELD_NUMBER;
        hash = (53 * hash) + getOpTypesList().hashCode();
      }
      hash = (37 * hash) + CANONICAL_DEVICE_FIELD_NUMBER;
      hash = (53 * hash) + getCanonicalDevice().hashCode();
      hash = (37 * hash) + HOST_DEVICE_FIELD_NUMBER;
      hash = (53 * hash) + getHostDevice().hashCode();
      hash = (37 * hash) + FLOAT_OPS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFloatOps());
      if (hasTrace()) {
        hash = (37 * hash) + TRACE_FIELD_NUMBER;
        hash = (53 * hash) + getTrace().hashCode();
      }
      if (!internalGetAttrs().getMap().isEmpty()) {
        hash = (37 * hash) + ATTRS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetAttrs().hashCode();
      }
      if (!internalGetExecs().getMap().isEmpty()) {
        hash = (37 * hash) + EXECS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetExecs().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ProfileNode parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.ProfileNode prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.ProfileNode}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.ProfileNode)
        tensorflow.tfprof.TfprofLog.ProfileNodeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetInputs();
          case 16:
            return internalGetInputShapes();
          case 3:
            return internalGetOutputs();
          case 15:
            return internalGetOutputShapes();
          case 14:
            return internalGetSrcOutputIndex();
          case 11:
            return internalGetAttrs();
          case 12:
            return internalGetExecs();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableInputs();
          case 16:
            return internalGetMutableInputShapes();
          case 3:
            return internalGetMutableOutputs();
          case 15:
            return internalGetMutableOutputShapes();
          case 14:
            return internalGetMutableSrcOutputIndex();
          case 11:
            return internalGetMutableAttrs();
          case 12:
            return internalGetMutableExecs();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.ProfileNode.class, tensorflow.tfprof.TfprofLog.ProfileNode.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.ProfileNode.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        op_ = "";

        id_ = 0L;

        internalGetMutableInputs().clear();
        internalGetMutableInputShapes().clear();
        internalGetMutableOutputs().clear();
        internalGetMutableOutputShapes().clear();
        internalGetMutableSrcOutputIndex().clear();
        shape_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000100);
        opTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        canonicalDevice_ = "";

        hostDevice_ = "";

        floatOps_ = 0L;

        if (traceBuilder_ == null) {
          trace_ = null;
        } else {
          trace_ = null;
          traceBuilder_ = null;
        }
        internalGetMutableAttrs().clear();
        internalGetMutableExecs().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ProfileNode_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.ProfileNode getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.ProfileNode.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.ProfileNode build() {
        tensorflow.tfprof.TfprofLog.ProfileNode result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.ProfileNode buildPartial() {
        tensorflow.tfprof.TfprofLog.ProfileNode result = new tensorflow.tfprof.TfprofLog.ProfileNode(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.name_ = name_;
        result.op_ = op_;
        result.id_ = id_;
        result.inputs_ = internalGetInputs();
        result.inputs_.makeImmutable();
        result.inputShapes_ = internalGetInputShapes();
        result.inputShapes_.makeImmutable();
        result.outputs_ = internalGetOutputs();
        result.outputs_.makeImmutable();
        result.outputShapes_ = internalGetOutputShapes();
        result.outputShapes_.makeImmutable();
        result.srcOutputIndex_ = internalGetSrcOutputIndex();
        result.srcOutputIndex_.makeImmutable();
        if (((bitField0_ & 0x00000100) == 0x00000100)) {
          shape_ = java.util.Collections.unmodifiableList(shape_);
          bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.shape_ = shape_;
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
          opTypes_ = opTypes_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.opTypes_ = opTypes_;
        result.canonicalDevice_ = canonicalDevice_;
        result.hostDevice_ = hostDevice_;
        result.floatOps_ = floatOps_;
        if (traceBuilder_ == null) {
          result.trace_ = trace_;
        } else {
          result.trace_ = traceBuilder_.build();
        }
        result.attrs_ = internalGetAttrs();
        result.attrs_.makeImmutable();
        result.execs_ = internalGetExecs();
        result.execs_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.ProfileNode) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.ProfileNode)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.ProfileNode other) {
        if (other == tensorflow.tfprof.TfprofLog.ProfileNode.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.getOp().isEmpty()) {
          op_ = other.op_;
          onChanged();
        }
        if (other.getId() != 0L) {
          setId(other.getId());
        }
        internalGetMutableInputs().mergeFrom(
            other.internalGetInputs());
        internalGetMutableInputShapes().mergeFrom(
            other.internalGetInputShapes());
        internalGetMutableOutputs().mergeFrom(
            other.internalGetOutputs());
        internalGetMutableOutputShapes().mergeFrom(
            other.internalGetOutputShapes());
        internalGetMutableSrcOutputIndex().mergeFrom(
            other.internalGetSrcOutputIndex());
        if (!other.shape_.isEmpty()) {
          if (shape_.isEmpty()) {
            shape_ = other.shape_;
            bitField0_ = (bitField0_ & ~0x00000100);
          } else {
            ensureShapeIsMutable();
            shape_.addAll(other.shape_);
          }
          onChanged();
        }
        if (!other.opTypes_.isEmpty()) {
          if (opTypes_.isEmpty()) {
            opTypes_ = other.opTypes_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureOpTypesIsMutable();
            opTypes_.addAll(other.opTypes_);
          }
          onChanged();
        }
        if (!other.getCanonicalDevice().isEmpty()) {
          canonicalDevice_ = other.canonicalDevice_;
          onChanged();
        }
        if (!other.getHostDevice().isEmpty()) {
          hostDevice_ = other.hostDevice_;
          onChanged();
        }
        if (other.getFloatOps() != 0L) {
          setFloatOps(other.getFloatOps());
        }
        if (other.hasTrace()) {
          mergeTrace(other.getTrace());
        }
        internalGetMutableAttrs().mergeFrom(
            other.internalGetAttrs());
        internalGetMutableExecs().mergeFrom(
            other.internalGetExecs());
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.ProfileNode parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.ProfileNode) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * graph node name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * graph node name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * graph node name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * graph node name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * graph node name.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object op_ = "";
      /**
       * <pre>
       * graph operation type.
       * </pre>
       *
       * <code>string op = 9;</code>
       */
      public java.lang.String getOp() {
        java.lang.Object ref = op_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          op_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * graph operation type.
       * </pre>
       *
       * <code>string op = 9;</code>
       */
      public com.google.protobuf.ByteString
          getOpBytes() {
        java.lang.Object ref = op_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          op_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * graph operation type.
       * </pre>
       *
       * <code>string op = 9;</code>
       */
      public Builder setOp(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        op_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * graph operation type.
       * </pre>
       *
       * <code>string op = 9;</code>
       */
      public Builder clearOp() {
        
        op_ = getDefaultInstance().getOp();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * graph operation type.
       * </pre>
       *
       * <code>string op = 9;</code>
       */
      public Builder setOpBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        op_ = value;
        onChanged();
        return this;
      }

      private long id_ ;
      /**
       * <pre>
       * A unique id for the node.
       * </pre>
       *
       * <code>int64 id = 13;</code>
       */
      public long getId() {
        return id_;
      }
      /**
       * <pre>
       * A unique id for the node.
       * </pre>
       *
       * <code>int64 id = 13;</code>
       */
      public Builder setId(long value) {
        
        id_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A unique id for the node.
       * </pre>
       *
       * <code>int64 id = 13;</code>
       */
      public Builder clearId() {
        
        id_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Integer, java.lang.Long> inputs_;
      private com.google.protobuf.MapField<java.lang.Integer, java.lang.Long>
      internalGetInputs() {
        if (inputs_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              InputsDefaultEntryHolder.defaultEntry);
        }
        return inputs_;
      }
      private com.google.protobuf.MapField<java.lang.Integer, java.lang.Long>
      internalGetMutableInputs() {
        onChanged();;
        if (inputs_ == null) {
          inputs_ = com.google.protobuf.MapField.newMapField(
              InputsDefaultEntryHolder.defaultEntry);
        }
        if (!inputs_.isMutable()) {
          inputs_ = inputs_.copy();
        }
        return inputs_;
      }

      public int getInputsCount() {
        return internalGetInputs().getMap().size();
      }
      /**
       * <code>map&lt;int32, int64&gt; inputs = 2;</code>
       */

      public boolean containsInputs(
          int key) {
        
        return internalGetInputs().getMap().containsKey(key);
      }
      /**
       * Use {@link #getInputsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, java.lang.Long> getInputs() {
        return getInputsMap();
      }
      /**
       * <code>map&lt;int32, int64&gt; inputs = 2;</code>
       */

      public java.util.Map<java.lang.Integer, java.lang.Long> getInputsMap() {
        return internalGetInputs().getMap();
      }
      /**
       * <code>map&lt;int32, int64&gt; inputs = 2;</code>
       */

      public long getInputsOrDefault(
          int key,
          long defaultValue) {
        
        java.util.Map<java.lang.Integer, java.lang.Long> map =
            internalGetInputs().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, int64&gt; inputs = 2;</code>
       */

      public long getInputsOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, java.lang.Long> map =
            internalGetInputs().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearInputs() {
        internalGetMutableInputs().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;int32, int64&gt; inputs = 2;</code>
       */

      public Builder removeInputs(
          int key) {
        
        internalGetMutableInputs().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, java.lang.Long>
      getMutableInputs() {
        return internalGetMutableInputs().getMutableMap();
      }
      /**
       * <code>map&lt;int32, int64&gt; inputs = 2;</code>
       */
      public Builder putInputs(
          int key,
          long value) {
        
        
        internalGetMutableInputs().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, int64&gt; inputs = 2;</code>
       */

      public Builder putAllInputs(
          java.util.Map<java.lang.Integer, java.lang.Long> values) {
        internalGetMutableInputs().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> inputShapes_;
      private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
      internalGetInputShapes() {
        if (inputShapes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              InputShapesDefaultEntryHolder.defaultEntry);
        }
        return inputShapes_;
      }
      private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
      internalGetMutableInputShapes() {
        onChanged();;
        if (inputShapes_ == null) {
          inputShapes_ = com.google.protobuf.MapField.newMapField(
              InputShapesDefaultEntryHolder.defaultEntry);
        }
        if (!inputShapes_.isMutable()) {
          inputShapes_ = inputShapes_.copy();
        }
        return inputShapes_;
      }

      public int getInputShapesCount() {
        return internalGetInputShapes().getMap().size();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
       */

      public boolean containsInputShapes(
          int key) {
        
        return internalGetInputShapes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getInputShapesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getInputShapes() {
        return getInputShapesMap();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
       */

      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getInputShapesMap() {
        return internalGetInputShapes().getMap();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
       */

      public tensorflow.tfprof.TfprofLog.Tuple getInputShapesOrDefault(
          int key,
          tensorflow.tfprof.TfprofLog.Tuple defaultValue) {
        
        java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
            internalGetInputShapes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
       */

      public tensorflow.tfprof.TfprofLog.Tuple getInputShapesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
            internalGetInputShapes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearInputShapes() {
        internalGetMutableInputShapes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
       */

      public Builder removeInputShapes(
          int key) {
        
        internalGetMutableInputShapes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
      getMutableInputShapes() {
        return internalGetMutableInputShapes().getMutableMap();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
       */
      public Builder putInputShapes(
          int key,
          tensorflow.tfprof.TfprofLog.Tuple value) {
        
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableInputShapes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; input_shapes = 16;</code>
       */

      public Builder putAllInputShapes(
          java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> values) {
        internalGetMutableInputShapes().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Integer, java.lang.Long> outputs_;
      private com.google.protobuf.MapField<java.lang.Integer, java.lang.Long>
      internalGetOutputs() {
        if (outputs_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              OutputsDefaultEntryHolder.defaultEntry);
        }
        return outputs_;
      }
      private com.google.protobuf.MapField<java.lang.Integer, java.lang.Long>
      internalGetMutableOutputs() {
        onChanged();;
        if (outputs_ == null) {
          outputs_ = com.google.protobuf.MapField.newMapField(
              OutputsDefaultEntryHolder.defaultEntry);
        }
        if (!outputs_.isMutable()) {
          outputs_ = outputs_.copy();
        }
        return outputs_;
      }

      public int getOutputsCount() {
        return internalGetOutputs().getMap().size();
      }
      /**
       * <code>map&lt;int32, int64&gt; outputs = 3;</code>
       */

      public boolean containsOutputs(
          int key) {
        
        return internalGetOutputs().getMap().containsKey(key);
      }
      /**
       * Use {@link #getOutputsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, java.lang.Long> getOutputs() {
        return getOutputsMap();
      }
      /**
       * <code>map&lt;int32, int64&gt; outputs = 3;</code>
       */

      public java.util.Map<java.lang.Integer, java.lang.Long> getOutputsMap() {
        return internalGetOutputs().getMap();
      }
      /**
       * <code>map&lt;int32, int64&gt; outputs = 3;</code>
       */

      public long getOutputsOrDefault(
          int key,
          long defaultValue) {
        
        java.util.Map<java.lang.Integer, java.lang.Long> map =
            internalGetOutputs().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, int64&gt; outputs = 3;</code>
       */

      public long getOutputsOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, java.lang.Long> map =
            internalGetOutputs().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearOutputs() {
        internalGetMutableOutputs().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;int32, int64&gt; outputs = 3;</code>
       */

      public Builder removeOutputs(
          int key) {
        
        internalGetMutableOutputs().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, java.lang.Long>
      getMutableOutputs() {
        return internalGetMutableOutputs().getMutableMap();
      }
      /**
       * <code>map&lt;int32, int64&gt; outputs = 3;</code>
       */
      public Builder putOutputs(
          int key,
          long value) {
        
        
        internalGetMutableOutputs().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, int64&gt; outputs = 3;</code>
       */

      public Builder putAllOutputs(
          java.util.Map<java.lang.Integer, java.lang.Long> values) {
        internalGetMutableOutputs().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> outputShapes_;
      private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
      internalGetOutputShapes() {
        if (outputShapes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              OutputShapesDefaultEntryHolder.defaultEntry);
        }
        return outputShapes_;
      }
      private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
      internalGetMutableOutputShapes() {
        onChanged();;
        if (outputShapes_ == null) {
          outputShapes_ = com.google.protobuf.MapField.newMapField(
              OutputShapesDefaultEntryHolder.defaultEntry);
        }
        if (!outputShapes_.isMutable()) {
          outputShapes_ = outputShapes_.copy();
        }
        return outputShapes_;
      }

      public int getOutputShapesCount() {
        return internalGetOutputShapes().getMap().size();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
       */

      public boolean containsOutputShapes(
          int key) {
        
        return internalGetOutputShapes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getOutputShapesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getOutputShapes() {
        return getOutputShapesMap();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
       */

      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> getOutputShapesMap() {
        return internalGetOutputShapes().getMap();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
       */

      public tensorflow.tfprof.TfprofLog.Tuple getOutputShapesOrDefault(
          int key,
          tensorflow.tfprof.TfprofLog.Tuple defaultValue) {
        
        java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
            internalGetOutputShapes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
       */

      public tensorflow.tfprof.TfprofLog.Tuple getOutputShapesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> map =
            internalGetOutputShapes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearOutputShapes() {
        internalGetMutableOutputShapes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
       */

      public Builder removeOutputShapes(
          int key) {
        
        internalGetMutableOutputShapes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple>
      getMutableOutputShapes() {
        return internalGetMutableOutputShapes().getMutableMap();
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
       */
      public Builder putOutputShapes(
          int key,
          tensorflow.tfprof.TfprofLog.Tuple value) {
        
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableOutputShapes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int32, .tensorflow.tfprof.Tuple&gt; output_shapes = 15;</code>
       */

      public Builder putAllOutputShapes(
          java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Tuple> values) {
        internalGetMutableOutputShapes().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Long, java.lang.Integer> srcOutputIndex_;
      private com.google.protobuf.MapField<java.lang.Long, java.lang.Integer>
      internalGetSrcOutputIndex() {
        if (srcOutputIndex_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SrcOutputIndexDefaultEntryHolder.defaultEntry);
        }
        return srcOutputIndex_;
      }
      private com.google.protobuf.MapField<java.lang.Long, java.lang.Integer>
      internalGetMutableSrcOutputIndex() {
        onChanged();;
        if (srcOutputIndex_ == null) {
          srcOutputIndex_ = com.google.protobuf.MapField.newMapField(
              SrcOutputIndexDefaultEntryHolder.defaultEntry);
        }
        if (!srcOutputIndex_.isMutable()) {
          srcOutputIndex_ = srcOutputIndex_.copy();
        }
        return srcOutputIndex_;
      }

      public int getSrcOutputIndexCount() {
        return internalGetSrcOutputIndex().getMap().size();
      }
      /**
       * <pre>
       * A map from source node id to its output index to current node.
       * </pre>
       *
       * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
       */

      public boolean containsSrcOutputIndex(
          long key) {
        
        return internalGetSrcOutputIndex().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSrcOutputIndexMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, java.lang.Integer> getSrcOutputIndex() {
        return getSrcOutputIndexMap();
      }
      /**
       * <pre>
       * A map from source node id to its output index to current node.
       * </pre>
       *
       * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
       */

      public java.util.Map<java.lang.Long, java.lang.Integer> getSrcOutputIndexMap() {
        return internalGetSrcOutputIndex().getMap();
      }
      /**
       * <pre>
       * A map from source node id to its output index to current node.
       * </pre>
       *
       * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
       */

      public int getSrcOutputIndexOrDefault(
          long key,
          int defaultValue) {
        
        java.util.Map<java.lang.Long, java.lang.Integer> map =
            internalGetSrcOutputIndex().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * A map from source node id to its output index to current node.
       * </pre>
       *
       * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
       */

      public int getSrcOutputIndexOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, java.lang.Integer> map =
            internalGetSrcOutputIndex().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSrcOutputIndex() {
        internalGetMutableSrcOutputIndex().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * A map from source node id to its output index to current node.
       * </pre>
       *
       * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
       */

      public Builder removeSrcOutputIndex(
          long key) {
        
        internalGetMutableSrcOutputIndex().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, java.lang.Integer>
      getMutableSrcOutputIndex() {
        return internalGetMutableSrcOutputIndex().getMutableMap();
      }
      /**
       * <pre>
       * A map from source node id to its output index to current node.
       * </pre>
       *
       * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
       */
      public Builder putSrcOutputIndex(
          long key,
          int value) {
        
        
        internalGetMutableSrcOutputIndex().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * A map from source node id to its output index to current node.
       * </pre>
       *
       * <code>map&lt;int64, int32&gt; src_output_index = 14;</code>
       */

      public Builder putAllSrcOutputIndex(
          java.util.Map<java.lang.Long, java.lang.Integer> values) {
        internalGetMutableSrcOutputIndex().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.util.List<java.lang.Long> shape_ = java.util.Collections.emptyList();
      private void ensureShapeIsMutable() {
        if (!((bitField0_ & 0x00000100) == 0x00000100)) {
          shape_ = new java.util.ArrayList<java.lang.Long>(shape_);
          bitField0_ |= 0x00000100;
         }
      }
      /**
       * <code>repeated int64 shape = 4;</code>
       */
      public java.util.List<java.lang.Long>
          getShapeList() {
        return java.util.Collections.unmodifiableList(shape_);
      }
      /**
       * <code>repeated int64 shape = 4;</code>
       */
      public int getShapeCount() {
        return shape_.size();
      }
      /**
       * <code>repeated int64 shape = 4;</code>
       */
      public long getShape(int index) {
        return shape_.get(index);
      }
      /**
       * <code>repeated int64 shape = 4;</code>
       */
      public Builder setShape(
          int index, long value) {
        ensureShapeIsMutable();
        shape_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 shape = 4;</code>
       */
      public Builder addShape(long value) {
        ensureShapeIsMutable();
        shape_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 shape = 4;</code>
       */
      public Builder addAllShape(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureShapeIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, shape_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 shape = 4;</code>
       */
      public Builder clearShape() {
        shape_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList opTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureOpTypesIsMutable() {
        if (!((bitField0_ & 0x00000200) == 0x00000200)) {
          opTypes_ = new com.google.protobuf.LazyStringArrayList(opTypes_);
          bitField0_ |= 0x00000200;
         }
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getOpTypesList() {
        return opTypes_.getUnmodifiableView();
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public int getOpTypesCount() {
        return opTypes_.size();
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public java.lang.String getOpTypes(int index) {
        return opTypes_.get(index);
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public com.google.protobuf.ByteString
          getOpTypesBytes(int index) {
        return opTypes_.getByteString(index);
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public Builder setOpTypes(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOpTypesIsMutable();
        opTypes_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public Builder addOpTypes(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureOpTypesIsMutable();
        opTypes_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public Builder addAllOpTypes(
          java.lang.Iterable<java.lang.String> values) {
        ensureOpTypesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, opTypes_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public Builder clearOpTypes() {
        opTypes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string op_types = 5;</code>
       */
      public Builder addOpTypesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureOpTypesIsMutable();
        opTypes_.add(value);
        onChanged();
        return this;
      }

      private java.lang.Object canonicalDevice_ = "";
      /**
       * <code>string canonical_device = 6;</code>
       */
      public java.lang.String getCanonicalDevice() {
        java.lang.Object ref = canonicalDevice_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          canonicalDevice_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string canonical_device = 6;</code>
       */
      public com.google.protobuf.ByteString
          getCanonicalDeviceBytes() {
        java.lang.Object ref = canonicalDevice_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          canonicalDevice_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string canonical_device = 6;</code>
       */
      public Builder setCanonicalDevice(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        canonicalDevice_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string canonical_device = 6;</code>
       */
      public Builder clearCanonicalDevice() {
        
        canonicalDevice_ = getDefaultInstance().getCanonicalDevice();
        onChanged();
        return this;
      }
      /**
       * <code>string canonical_device = 6;</code>
       */
      public Builder setCanonicalDeviceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        canonicalDevice_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object hostDevice_ = "";
      /**
       * <code>string host_device = 7;</code>
       */
      public java.lang.String getHostDevice() {
        java.lang.Object ref = hostDevice_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          hostDevice_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string host_device = 7;</code>
       */
      public com.google.protobuf.ByteString
          getHostDeviceBytes() {
        java.lang.Object ref = hostDevice_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          hostDevice_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string host_device = 7;</code>
       */
      public Builder setHostDevice(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        hostDevice_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string host_device = 7;</code>
       */
      public Builder clearHostDevice() {
        
        hostDevice_ = getDefaultInstance().getHostDevice();
        onChanged();
        return this;
      }
      /**
       * <code>string host_device = 7;</code>
       */
      public Builder setHostDeviceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        hostDevice_ = value;
        onChanged();
        return this;
      }

      private long floatOps_ ;
      /**
       * <code>int64 float_ops = 8;</code>
       */
      public long getFloatOps() {
        return floatOps_;
      }
      /**
       * <code>int64 float_ops = 8;</code>
       */
      public Builder setFloatOps(long value) {
        
        floatOps_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 float_ops = 8;</code>
       */
      public Builder clearFloatOps() {
        
        floatOps_ = 0L;
        onChanged();
        return this;
      }

      private tensorflow.tfprof.TfprofLog.CodeDef trace_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.CodeDef, tensorflow.tfprof.TfprofLog.CodeDef.Builder, tensorflow.tfprof.TfprofLog.CodeDefOrBuilder> traceBuilder_;
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public boolean hasTrace() {
        return traceBuilder_ != null || trace_ != null;
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef getTrace() {
        if (traceBuilder_ == null) {
          return trace_ == null ? tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance() : trace_;
        } else {
          return traceBuilder_.getMessage();
        }
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public Builder setTrace(tensorflow.tfprof.TfprofLog.CodeDef value) {
        if (traceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          trace_ = value;
          onChanged();
        } else {
          traceBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public Builder setTrace(
          tensorflow.tfprof.TfprofLog.CodeDef.Builder builderForValue) {
        if (traceBuilder_ == null) {
          trace_ = builderForValue.build();
          onChanged();
        } else {
          traceBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public Builder mergeTrace(tensorflow.tfprof.TfprofLog.CodeDef value) {
        if (traceBuilder_ == null) {
          if (trace_ != null) {
            trace_ =
              tensorflow.tfprof.TfprofLog.CodeDef.newBuilder(trace_).mergeFrom(value).buildPartial();
          } else {
            trace_ = value;
          }
          onChanged();
        } else {
          traceBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public Builder clearTrace() {
        if (traceBuilder_ == null) {
          trace_ = null;
          onChanged();
        } else {
          trace_ = null;
          traceBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDef.Builder getTraceBuilder() {
        
        onChanged();
        return getTraceFieldBuilder().getBuilder();
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      public tensorflow.tfprof.TfprofLog.CodeDefOrBuilder getTraceOrBuilder() {
        if (traceBuilder_ != null) {
          return traceBuilder_.getMessageOrBuilder();
        } else {
          return trace_ == null ?
              tensorflow.tfprof.TfprofLog.CodeDef.getDefaultInstance() : trace_;
        }
      }
      /**
       * <code>.tensorflow.tfprof.CodeDef trace = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.CodeDef, tensorflow.tfprof.TfprofLog.CodeDef.Builder, tensorflow.tfprof.TfprofLog.CodeDefOrBuilder> 
          getTraceFieldBuilder() {
        if (traceBuilder_ == null) {
          traceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              tensorflow.tfprof.TfprofLog.CodeDef, tensorflow.tfprof.TfprofLog.CodeDef.Builder, tensorflow.tfprof.TfprofLog.CodeDefOrBuilder>(
                  getTrace(),
                  getParentForChildren(),
                  isClean());
          trace_ = null;
        }
        return traceBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, org.tensorflow.framework.AttrValue> attrs_;
      private com.google.protobuf.MapField<java.lang.String, org.tensorflow.framework.AttrValue>
      internalGetAttrs() {
        if (attrs_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              AttrsDefaultEntryHolder.defaultEntry);
        }
        return attrs_;
      }
      private com.google.protobuf.MapField<java.lang.String, org.tensorflow.framework.AttrValue>
      internalGetMutableAttrs() {
        onChanged();;
        if (attrs_ == null) {
          attrs_ = com.google.protobuf.MapField.newMapField(
              AttrsDefaultEntryHolder.defaultEntry);
        }
        if (!attrs_.isMutable()) {
          attrs_ = attrs_.copy();
        }
        return attrs_;
      }

      public int getAttrsCount() {
        return internalGetAttrs().getMap().size();
      }
      /**
       * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
       */

      public boolean containsAttrs(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetAttrs().getMap().containsKey(key);
      }
      /**
       * Use {@link #getAttrsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> getAttrs() {
        return getAttrsMap();
      }
      /**
       * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
       */

      public java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> getAttrsMap() {
        return internalGetAttrs().getMap();
      }
      /**
       * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
       */

      public org.tensorflow.framework.AttrValue getAttrsOrDefault(
          java.lang.String key,
          org.tensorflow.framework.AttrValue defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> map =
            internalGetAttrs().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
       */

      public org.tensorflow.framework.AttrValue getAttrsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> map =
            internalGetAttrs().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearAttrs() {
        internalGetMutableAttrs().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
       */

      public Builder removeAttrs(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableAttrs().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue>
      getMutableAttrs() {
        return internalGetMutableAttrs().getMutableMap();
      }
      /**
       * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
       */
      public Builder putAttrs(
          java.lang.String key,
          org.tensorflow.framework.AttrValue value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableAttrs().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .tensorflow.AttrValue&gt; attrs = 11;</code>
       */

      public Builder putAllAttrs(
          java.util.Map<java.lang.String, org.tensorflow.framework.AttrValue> values) {
        internalGetMutableAttrs().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> execs_;
      private com.google.protobuf.MapField<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
      internalGetExecs() {
        if (execs_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ExecsDefaultEntryHolder.defaultEntry);
        }
        return execs_;
      }
      private com.google.protobuf.MapField<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
      internalGetMutableExecs() {
        onChanged();;
        if (execs_ == null) {
          execs_ = com.google.protobuf.MapField.newMapField(
              ExecsDefaultEntryHolder.defaultEntry);
        }
        if (!execs_.isMutable()) {
          execs_ = execs_.copy();
        }
        return execs_;
      }

      public int getExecsCount() {
        return internalGetExecs().getMap().size();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
       */

      public boolean containsExecs(
          long key) {
        
        return internalGetExecs().getMap().containsKey(key);
      }
      /**
       * Use {@link #getExecsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> getExecs() {
        return getExecsMap();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
       */

      public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> getExecsMap() {
        return internalGetExecs().getMap();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
       */

      public tensorflow.tfprof.TfprofLog.ExecProfile getExecsOrDefault(
          long key,
          tensorflow.tfprof.TfprofLog.ExecProfile defaultValue) {
        
        java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> map =
            internalGetExecs().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
       */

      public tensorflow.tfprof.TfprofLog.ExecProfile getExecsOrThrow(
          long key) {
        
        java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> map =
            internalGetExecs().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearExecs() {
        internalGetMutableExecs().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
       */

      public Builder removeExecs(
          long key) {
        
        internalGetMutableExecs().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile>
      getMutableExecs() {
        return internalGetMutableExecs().getMutableMap();
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
       */
      public Builder putExecs(
          long key,
          tensorflow.tfprof.TfprofLog.ExecProfile value) {
        
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableExecs().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;int64, .tensorflow.tfprof.ExecProfile&gt; execs = 12;</code>
       */

      public Builder putAllExecs(
          java.util.Map<java.lang.Long, tensorflow.tfprof.TfprofLog.ExecProfile> values) {
        internalGetMutableExecs().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.ProfileNode)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.ProfileNode)
    private static final tensorflow.tfprof.TfprofLog.ProfileNode DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.ProfileNode();
    }

    public static tensorflow.tfprof.TfprofLog.ProfileNode getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProfileNode>
        PARSER = new com.google.protobuf.AbstractParser<ProfileNode>() {
      public ProfileNode parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new ProfileNode(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ProfileNode> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProfileNode> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.ProfileNode getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExecProfileOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.ExecProfile)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Can be larger than 1 if run multiple times in loop.
     * </pre>
     *
     * <code>int64 run_count = 1;</code>
     */
    long getRunCount();

    /**
     * <pre>
     * The earliest/latest time including scheduling and execution.
     * </pre>
     *
     * <code>int64 all_start_micros = 2;</code>
     */
    long getAllStartMicros();

    /**
     * <code>int64 latest_end_micros = 3;</code>
     */
    long getLatestEndMicros();

    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */
    int getAcceleratorExecsCount();
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */
    boolean containsAcceleratorExecs(
        java.lang.String key);
    /**
     * Use {@link #getAcceleratorExecsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
    getAcceleratorExecs();
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */
    java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
    getAcceleratorExecsMap();
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */

    tensorflow.tfprof.TfprofLog.ExecTime getAcceleratorExecsOrDefault(
        java.lang.String key,
        tensorflow.tfprof.TfprofLog.ExecTime defaultValue);
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */

    tensorflow.tfprof.TfprofLog.ExecTime getAcceleratorExecsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */
    int getCpuExecsCount();
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */
    boolean containsCpuExecs(
        java.lang.String key);
    /**
     * Use {@link #getCpuExecsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
    getCpuExecs();
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */
    java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
    getCpuExecsMap();
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */

    tensorflow.tfprof.TfprofLog.ExecTime getCpuExecsOrDefault(
        java.lang.String key,
        tensorflow.tfprof.TfprofLog.ExecTime defaultValue);
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */

    tensorflow.tfprof.TfprofLog.ExecTime getCpuExecsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    java.util.List<tensorflow.tfprof.TfprofLog.ExecMemory> 
        getMemoryExecsList();
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    tensorflow.tfprof.TfprofLog.ExecMemory getMemoryExecs(int index);
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    int getMemoryExecsCount();
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    java.util.List<? extends tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder> 
        getMemoryExecsOrBuilderList();
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder getMemoryExecsOrBuilder(
        int index);

    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    java.util.List<org.tensorflow.framework.AllocationRecord> 
        getAllocationsList();
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    org.tensorflow.framework.AllocationRecord getAllocations(int index);
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    int getAllocationsCount();
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    java.util.List<? extends org.tensorflow.framework.AllocationRecordOrBuilder> 
        getAllocationsOrBuilderList();
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    org.tensorflow.framework.AllocationRecordOrBuilder getAllocationsOrBuilder(
        int index);

    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    java.util.List<java.lang.String>
        getDevicesList();
    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    int getDevicesCount();
    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    java.lang.String getDevices(int index);
    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    com.google.protobuf.ByteString
        getDevicesBytes(int index);
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.ExecProfile}
   */
  public  static final class ExecProfile extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.ExecProfile)
      ExecProfileOrBuilder {
    // Use ExecProfile.newBuilder() to construct.
    private ExecProfile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ExecProfile() {
      runCount_ = 0L;
      allStartMicros_ = 0L;
      latestEndMicros_ = 0L;
      memoryExecs_ = java.util.Collections.emptyList();
      allocations_ = java.util.Collections.emptyList();
      devices_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private ExecProfile(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              runCount_ = input.readInt64();
              break;
            }
            case 16: {

              allStartMicros_ = input.readInt64();
              break;
            }
            case 24: {

              latestEndMicros_ = input.readInt64();
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                acceleratorExecs_ = com.google.protobuf.MapField.newMapField(
                    AcceleratorExecsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
              acceleratorExecs__ = input.readMessage(
                  AcceleratorExecsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              acceleratorExecs_.getMutableMap().put(
                  acceleratorExecs__.getKey(), acceleratorExecs__.getValue());
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                cpuExecs_ = com.google.protobuf.MapField.newMapField(
                    CpuExecsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
              cpuExecs__ = input.readMessage(
                  CpuExecsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              cpuExecs_.getMutableMap().put(
                  cpuExecs__.getKey(), cpuExecs__.getValue());
              break;
            }
            case 50: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                devices_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000080;
              }
              devices_.add(s);
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                memoryExecs_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.ExecMemory>();
                mutable_bitField0_ |= 0x00000020;
              }
              memoryExecs_.add(
                  input.readMessage(tensorflow.tfprof.TfprofLog.ExecMemory.parser(), extensionRegistry));
              break;
            }
            case 90: {
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                allocations_ = new java.util.ArrayList<org.tensorflow.framework.AllocationRecord>();
                mutable_bitField0_ |= 0x00000040;
              }
              allocations_.add(
                  input.readMessage(org.tensorflow.framework.AllocationRecord.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
          devices_ = devices_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
          memoryExecs_ = java.util.Collections.unmodifiableList(memoryExecs_);
        }
        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
          allocations_ = java.util.Collections.unmodifiableList(allocations_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecProfile_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 4:
          return internalGetAcceleratorExecs();
        case 5:
          return internalGetCpuExecs();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecProfile_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.ExecProfile.class, tensorflow.tfprof.TfprofLog.ExecProfile.Builder.class);
    }

    private int bitField0_;
    public static final int RUN_COUNT_FIELD_NUMBER = 1;
    private long runCount_;
    /**
     * <pre>
     * Can be larger than 1 if run multiple times in loop.
     * </pre>
     *
     * <code>int64 run_count = 1;</code>
     */
    public long getRunCount() {
      return runCount_;
    }

    public static final int ALL_START_MICROS_FIELD_NUMBER = 2;
    private long allStartMicros_;
    /**
     * <pre>
     * The earliest/latest time including scheduling and execution.
     * </pre>
     *
     * <code>int64 all_start_micros = 2;</code>
     */
    public long getAllStartMicros() {
      return allStartMicros_;
    }

    public static final int LATEST_END_MICROS_FIELD_NUMBER = 3;
    private long latestEndMicros_;
    /**
     * <code>int64 latest_end_micros = 3;</code>
     */
    public long getLatestEndMicros() {
      return latestEndMicros_;
    }

    public static final int ACCELERATOR_EXECS_FIELD_NUMBER = 4;
    private static final class AcceleratorExecsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecProfile_AcceleratorExecsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  tensorflow.tfprof.TfprofLog.ExecTime.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> acceleratorExecs_;
    private com.google.protobuf.MapField<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
    internalGetAcceleratorExecs() {
      if (acceleratorExecs_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            AcceleratorExecsDefaultEntryHolder.defaultEntry);
      }
      return acceleratorExecs_;
    }

    public int getAcceleratorExecsCount() {
      return internalGetAcceleratorExecs().getMap().size();
    }
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */

    public boolean containsAcceleratorExecs(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetAcceleratorExecs().getMap().containsKey(key);
    }
    /**
     * Use {@link #getAcceleratorExecsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getAcceleratorExecs() {
      return getAcceleratorExecsMap();
    }
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */

    public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getAcceleratorExecsMap() {
      return internalGetAcceleratorExecs().getMap();
    }
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */

    public tensorflow.tfprof.TfprofLog.ExecTime getAcceleratorExecsOrDefault(
        java.lang.String key,
        tensorflow.tfprof.TfprofLog.ExecTime defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
          internalGetAcceleratorExecs().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
     * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
     * For accelerator, vector size can be larger than 1, multiple kernel fires
     * or in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
     */

    public tensorflow.tfprof.TfprofLog.ExecTime getAcceleratorExecsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
          internalGetAcceleratorExecs().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int CPU_EXECS_FIELD_NUMBER = 5;
    private static final class CpuExecsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecProfile_CpuExecsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  tensorflow.tfprof.TfprofLog.ExecTime.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> cpuExecs_;
    private com.google.protobuf.MapField<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
    internalGetCpuExecs() {
      if (cpuExecs_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            CpuExecsDefaultEntryHolder.defaultEntry);
      }
      return cpuExecs_;
    }

    public int getCpuExecsCount() {
      return internalGetCpuExecs().getMap().size();
    }
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */

    public boolean containsCpuExecs(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetCpuExecs().getMap().containsKey(key);
    }
    /**
     * Use {@link #getCpuExecsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getCpuExecs() {
      return getCpuExecsMap();
    }
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */

    public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getCpuExecsMap() {
      return internalGetCpuExecs().getMap();
    }
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */

    public tensorflow.tfprof.TfprofLog.ExecTime getCpuExecsOrDefault(
        java.lang.String key,
        tensorflow.tfprof.TfprofLog.ExecTime defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
          internalGetCpuExecs().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
     * For cpu, vector size can be larger than 1 if in tf.while_loop.
     * </pre>
     *
     * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
     */

    public tensorflow.tfprof.TfprofLog.ExecTime getCpuExecsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
          internalGetCpuExecs().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int MEMORY_EXECS_FIELD_NUMBER = 7;
    private java.util.List<tensorflow.tfprof.TfprofLog.ExecMemory> memoryExecs_;
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    public java.util.List<tensorflow.tfprof.TfprofLog.ExecMemory> getMemoryExecsList() {
      return memoryExecs_;
    }
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    public java.util.List<? extends tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder> 
        getMemoryExecsOrBuilderList() {
      return memoryExecs_;
    }
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    public int getMemoryExecsCount() {
      return memoryExecs_.size();
    }
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    public tensorflow.tfprof.TfprofLog.ExecMemory getMemoryExecs(int index) {
      return memoryExecs_.get(index);
    }
    /**
     * <pre>
     * Each entry to memory information of a scheduling of the node.
     * Normally, there will be multiple entries in while_loop.
     * </pre>
     *
     * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
     */
    public tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder getMemoryExecsOrBuilder(
        int index) {
      return memoryExecs_.get(index);
    }

    public static final int ALLOCATIONS_FIELD_NUMBER = 11;
    private java.util.List<org.tensorflow.framework.AllocationRecord> allocations_;
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    public java.util.List<org.tensorflow.framework.AllocationRecord> getAllocationsList() {
      return allocations_;
    }
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    public java.util.List<? extends org.tensorflow.framework.AllocationRecordOrBuilder> 
        getAllocationsOrBuilderList() {
      return allocations_;
    }
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    public int getAllocationsCount() {
      return allocations_.size();
    }
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    public org.tensorflow.framework.AllocationRecord getAllocations(int index) {
      return allocations_.get(index);
    }
    /**
     * <pre>
     * The allocation and deallocation times and sizes throughout execution.
     * </pre>
     *
     * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
     */
    public org.tensorflow.framework.AllocationRecordOrBuilder getAllocationsOrBuilder(
        int index) {
      return allocations_.get(index);
    }

    public static final int DEVICES_FIELD_NUMBER = 6;
    private com.google.protobuf.LazyStringList devices_;
    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getDevicesList() {
      return devices_;
    }
    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    public int getDevicesCount() {
      return devices_.size();
    }
    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    public java.lang.String getDevices(int index) {
      return devices_.get(index);
    }
    /**
     * <pre>
     * The devices related to this execution.
     * </pre>
     *
     * <code>repeated string devices = 6;</code>
     */
    public com.google.protobuf.ByteString
        getDevicesBytes(int index) {
      return devices_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (runCount_ != 0L) {
        output.writeInt64(1, runCount_);
      }
      if (allStartMicros_ != 0L) {
        output.writeInt64(2, allStartMicros_);
      }
      if (latestEndMicros_ != 0L) {
        output.writeInt64(3, latestEndMicros_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetAcceleratorExecs(),
          AcceleratorExecsDefaultEntryHolder.defaultEntry,
          4);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetCpuExecs(),
          CpuExecsDefaultEntryHolder.defaultEntry,
          5);
      for (int i = 0; i < devices_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, devices_.getRaw(i));
      }
      for (int i = 0; i < memoryExecs_.size(); i++) {
        output.writeMessage(7, memoryExecs_.get(i));
      }
      for (int i = 0; i < allocations_.size(); i++) {
        output.writeMessage(11, allocations_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (runCount_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, runCount_);
      }
      if (allStartMicros_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, allStartMicros_);
      }
      if (latestEndMicros_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, latestEndMicros_);
      }
      for (java.util.Map.Entry<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> entry
           : internalGetAcceleratorExecs().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
        acceleratorExecs__ = AcceleratorExecsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, acceleratorExecs__);
      }
      for (java.util.Map.Entry<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> entry
           : internalGetCpuExecs().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
        cpuExecs__ = CpuExecsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, cpuExecs__);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < devices_.size(); i++) {
          dataSize += computeStringSizeNoTag(devices_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDevicesList().size();
      }
      for (int i = 0; i < memoryExecs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, memoryExecs_.get(i));
      }
      for (int i = 0; i < allocations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, allocations_.get(i));
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.ExecProfile)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.ExecProfile other = (tensorflow.tfprof.TfprofLog.ExecProfile) obj;

      boolean result = true;
      result = result && (getRunCount()
          == other.getRunCount());
      result = result && (getAllStartMicros()
          == other.getAllStartMicros());
      result = result && (getLatestEndMicros()
          == other.getLatestEndMicros());
      result = result && internalGetAcceleratorExecs().equals(
          other.internalGetAcceleratorExecs());
      result = result && internalGetCpuExecs().equals(
          other.internalGetCpuExecs());
      result = result && getMemoryExecsList()
          .equals(other.getMemoryExecsList());
      result = result && getAllocationsList()
          .equals(other.getAllocationsList());
      result = result && getDevicesList()
          .equals(other.getDevicesList());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + RUN_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getRunCount());
      hash = (37 * hash) + ALL_START_MICROS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAllStartMicros());
      hash = (37 * hash) + LATEST_END_MICROS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLatestEndMicros());
      if (!internalGetAcceleratorExecs().getMap().isEmpty()) {
        hash = (37 * hash) + ACCELERATOR_EXECS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetAcceleratorExecs().hashCode();
      }
      if (!internalGetCpuExecs().getMap().isEmpty()) {
        hash = (37 * hash) + CPU_EXECS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetCpuExecs().hashCode();
      }
      if (getMemoryExecsCount() > 0) {
        hash = (37 * hash) + MEMORY_EXECS_FIELD_NUMBER;
        hash = (53 * hash) + getMemoryExecsList().hashCode();
      }
      if (getAllocationsCount() > 0) {
        hash = (37 * hash) + ALLOCATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getAllocationsList().hashCode();
      }
      if (getDevicesCount() > 0) {
        hash = (37 * hash) + DEVICES_FIELD_NUMBER;
        hash = (53 * hash) + getDevicesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecProfile parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.ExecProfile prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.ExecProfile}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.ExecProfile)
        tensorflow.tfprof.TfprofLog.ExecProfileOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecProfile_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetAcceleratorExecs();
          case 5:
            return internalGetCpuExecs();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetMutableAcceleratorExecs();
          case 5:
            return internalGetMutableCpuExecs();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecProfile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.ExecProfile.class, tensorflow.tfprof.TfprofLog.ExecProfile.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.ExecProfile.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMemoryExecsFieldBuilder();
          getAllocationsFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        runCount_ = 0L;

        allStartMicros_ = 0L;

        latestEndMicros_ = 0L;

        internalGetMutableAcceleratorExecs().clear();
        internalGetMutableCpuExecs().clear();
        if (memoryExecsBuilder_ == null) {
          memoryExecs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          memoryExecsBuilder_.clear();
        }
        if (allocationsBuilder_ == null) {
          allocations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
        } else {
          allocationsBuilder_.clear();
        }
        devices_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecProfile_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.ExecProfile getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.ExecProfile.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.ExecProfile build() {
        tensorflow.tfprof.TfprofLog.ExecProfile result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.ExecProfile buildPartial() {
        tensorflow.tfprof.TfprofLog.ExecProfile result = new tensorflow.tfprof.TfprofLog.ExecProfile(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.runCount_ = runCount_;
        result.allStartMicros_ = allStartMicros_;
        result.latestEndMicros_ = latestEndMicros_;
        result.acceleratorExecs_ = internalGetAcceleratorExecs();
        result.acceleratorExecs_.makeImmutable();
        result.cpuExecs_ = internalGetCpuExecs();
        result.cpuExecs_.makeImmutable();
        if (memoryExecsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020)) {
            memoryExecs_ = java.util.Collections.unmodifiableList(memoryExecs_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.memoryExecs_ = memoryExecs_;
        } else {
          result.memoryExecs_ = memoryExecsBuilder_.build();
        }
        if (allocationsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) == 0x00000040)) {
            allocations_ = java.util.Collections.unmodifiableList(allocations_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.allocations_ = allocations_;
        } else {
          result.allocations_ = allocationsBuilder_.build();
        }
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
          devices_ = devices_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.devices_ = devices_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.ExecProfile) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.ExecProfile)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.ExecProfile other) {
        if (other == tensorflow.tfprof.TfprofLog.ExecProfile.getDefaultInstance()) return this;
        if (other.getRunCount() != 0L) {
          setRunCount(other.getRunCount());
        }
        if (other.getAllStartMicros() != 0L) {
          setAllStartMicros(other.getAllStartMicros());
        }
        if (other.getLatestEndMicros() != 0L) {
          setLatestEndMicros(other.getLatestEndMicros());
        }
        internalGetMutableAcceleratorExecs().mergeFrom(
            other.internalGetAcceleratorExecs());
        internalGetMutableCpuExecs().mergeFrom(
            other.internalGetCpuExecs());
        if (memoryExecsBuilder_ == null) {
          if (!other.memoryExecs_.isEmpty()) {
            if (memoryExecs_.isEmpty()) {
              memoryExecs_ = other.memoryExecs_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureMemoryExecsIsMutable();
              memoryExecs_.addAll(other.memoryExecs_);
            }
            onChanged();
          }
        } else {
          if (!other.memoryExecs_.isEmpty()) {
            if (memoryExecsBuilder_.isEmpty()) {
              memoryExecsBuilder_.dispose();
              memoryExecsBuilder_ = null;
              memoryExecs_ = other.memoryExecs_;
              bitField0_ = (bitField0_ & ~0x00000020);
              memoryExecsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMemoryExecsFieldBuilder() : null;
            } else {
              memoryExecsBuilder_.addAllMessages(other.memoryExecs_);
            }
          }
        }
        if (allocationsBuilder_ == null) {
          if (!other.allocations_.isEmpty()) {
            if (allocations_.isEmpty()) {
              allocations_ = other.allocations_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureAllocationsIsMutable();
              allocations_.addAll(other.allocations_);
            }
            onChanged();
          }
        } else {
          if (!other.allocations_.isEmpty()) {
            if (allocationsBuilder_.isEmpty()) {
              allocationsBuilder_.dispose();
              allocationsBuilder_ = null;
              allocations_ = other.allocations_;
              bitField0_ = (bitField0_ & ~0x00000040);
              allocationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getAllocationsFieldBuilder() : null;
            } else {
              allocationsBuilder_.addAllMessages(other.allocations_);
            }
          }
        }
        if (!other.devices_.isEmpty()) {
          if (devices_.isEmpty()) {
            devices_ = other.devices_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureDevicesIsMutable();
            devices_.addAll(other.devices_);
          }
          onChanged();
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.ExecProfile parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.ExecProfile) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long runCount_ ;
      /**
       * <pre>
       * Can be larger than 1 if run multiple times in loop.
       * </pre>
       *
       * <code>int64 run_count = 1;</code>
       */
      public long getRunCount() {
        return runCount_;
      }
      /**
       * <pre>
       * Can be larger than 1 if run multiple times in loop.
       * </pre>
       *
       * <code>int64 run_count = 1;</code>
       */
      public Builder setRunCount(long value) {
        
        runCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Can be larger than 1 if run multiple times in loop.
       * </pre>
       *
       * <code>int64 run_count = 1;</code>
       */
      public Builder clearRunCount() {
        
        runCount_ = 0L;
        onChanged();
        return this;
      }

      private long allStartMicros_ ;
      /**
       * <pre>
       * The earliest/latest time including scheduling and execution.
       * </pre>
       *
       * <code>int64 all_start_micros = 2;</code>
       */
      public long getAllStartMicros() {
        return allStartMicros_;
      }
      /**
       * <pre>
       * The earliest/latest time including scheduling and execution.
       * </pre>
       *
       * <code>int64 all_start_micros = 2;</code>
       */
      public Builder setAllStartMicros(long value) {
        
        allStartMicros_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The earliest/latest time including scheduling and execution.
       * </pre>
       *
       * <code>int64 all_start_micros = 2;</code>
       */
      public Builder clearAllStartMicros() {
        
        allStartMicros_ = 0L;
        onChanged();
        return this;
      }

      private long latestEndMicros_ ;
      /**
       * <code>int64 latest_end_micros = 3;</code>
       */
      public long getLatestEndMicros() {
        return latestEndMicros_;
      }
      /**
       * <code>int64 latest_end_micros = 3;</code>
       */
      public Builder setLatestEndMicros(long value) {
        
        latestEndMicros_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 latest_end_micros = 3;</code>
       */
      public Builder clearLatestEndMicros() {
        
        latestEndMicros_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> acceleratorExecs_;
      private com.google.protobuf.MapField<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
      internalGetAcceleratorExecs() {
        if (acceleratorExecs_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              AcceleratorExecsDefaultEntryHolder.defaultEntry);
        }
        return acceleratorExecs_;
      }
      private com.google.protobuf.MapField<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
      internalGetMutableAcceleratorExecs() {
        onChanged();;
        if (acceleratorExecs_ == null) {
          acceleratorExecs_ = com.google.protobuf.MapField.newMapField(
              AcceleratorExecsDefaultEntryHolder.defaultEntry);
        }
        if (!acceleratorExecs_.isMutable()) {
          acceleratorExecs_ = acceleratorExecs_.copy();
        }
        return acceleratorExecs_;
      }

      public int getAcceleratorExecsCount() {
        return internalGetAcceleratorExecs().getMap().size();
      }
      /**
       * <pre>
       * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
       * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
       * For accelerator, vector size can be larger than 1, multiple kernel fires
       * or in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
       */

      public boolean containsAcceleratorExecs(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetAcceleratorExecs().getMap().containsKey(key);
      }
      /**
       * Use {@link #getAcceleratorExecsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getAcceleratorExecs() {
        return getAcceleratorExecsMap();
      }
      /**
       * <pre>
       * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
       * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
       * For accelerator, vector size can be larger than 1, multiple kernel fires
       * or in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
       */

      public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getAcceleratorExecsMap() {
        return internalGetAcceleratorExecs().getMap();
      }
      /**
       * <pre>
       * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
       * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
       * For accelerator, vector size can be larger than 1, multiple kernel fires
       * or in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
       */

      public tensorflow.tfprof.TfprofLog.ExecTime getAcceleratorExecsOrDefault(
          java.lang.String key,
          tensorflow.tfprof.TfprofLog.ExecTime defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
            internalGetAcceleratorExecs().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
       * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
       * For accelerator, vector size can be larger than 1, multiple kernel fires
       * or in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
       */

      public tensorflow.tfprof.TfprofLog.ExecTime getAcceleratorExecsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
            internalGetAcceleratorExecs().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearAcceleratorExecs() {
        internalGetMutableAcceleratorExecs().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
       * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
       * For accelerator, vector size can be larger than 1, multiple kernel fires
       * or in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
       */

      public Builder removeAcceleratorExecs(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableAcceleratorExecs().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
      getMutableAcceleratorExecs() {
        return internalGetMutableAcceleratorExecs().getMutableMap();
      }
      /**
       * <pre>
       * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
       * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
       * For accelerator, vector size can be larger than 1, multiple kernel fires
       * or in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
       */
      public Builder putAcceleratorExecs(
          java.lang.String key,
          tensorflow.tfprof.TfprofLog.ExecTime value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableAcceleratorExecs().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * device -&gt; vector of {op_start_micros, op_exec_micros} pairs.
       * accelerator_execs: gpu:id/stream:all -&gt; {op_start_micros, op_exec_micros}
       * For accelerator, vector size can be larger than 1, multiple kernel fires
       * or in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; accelerator_execs = 4;</code>
       */

      public Builder putAllAcceleratorExecs(
          java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> values) {
        internalGetMutableAcceleratorExecs().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> cpuExecs_;
      private com.google.protobuf.MapField<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
      internalGetCpuExecs() {
        if (cpuExecs_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              CpuExecsDefaultEntryHolder.defaultEntry);
        }
        return cpuExecs_;
      }
      private com.google.protobuf.MapField<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
      internalGetMutableCpuExecs() {
        onChanged();;
        if (cpuExecs_ == null) {
          cpuExecs_ = com.google.protobuf.MapField.newMapField(
              CpuExecsDefaultEntryHolder.defaultEntry);
        }
        if (!cpuExecs_.isMutable()) {
          cpuExecs_ = cpuExecs_.copy();
        }
        return cpuExecs_;
      }

      public int getCpuExecsCount() {
        return internalGetCpuExecs().getMap().size();
      }
      /**
       * <pre>
       * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
       * For cpu, vector size can be larger than 1 if in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
       */

      public boolean containsCpuExecs(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetCpuExecs().getMap().containsKey(key);
      }
      /**
       * Use {@link #getCpuExecsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getCpuExecs() {
        return getCpuExecsMap();
      }
      /**
       * <pre>
       * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
       * For cpu, vector size can be larger than 1 if in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
       */

      public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> getCpuExecsMap() {
        return internalGetCpuExecs().getMap();
      }
      /**
       * <pre>
       * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
       * For cpu, vector size can be larger than 1 if in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
       */

      public tensorflow.tfprof.TfprofLog.ExecTime getCpuExecsOrDefault(
          java.lang.String key,
          tensorflow.tfprof.TfprofLog.ExecTime defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
            internalGetCpuExecs().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
       * For cpu, vector size can be larger than 1 if in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
       */

      public tensorflow.tfprof.TfprofLog.ExecTime getCpuExecsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> map =
            internalGetCpuExecs().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearCpuExecs() {
        internalGetMutableCpuExecs().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
       * For cpu, vector size can be larger than 1 if in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
       */

      public Builder removeCpuExecs(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableCpuExecs().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime>
      getMutableCpuExecs() {
        return internalGetMutableCpuExecs().getMutableMap();
      }
      /**
       * <pre>
       * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
       * For cpu, vector size can be larger than 1 if in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
       */
      public Builder putCpuExecs(
          java.lang.String key,
          tensorflow.tfprof.TfprofLog.ExecTime value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableCpuExecs().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * cpu_execs: cpu/gpu:id -&gt; {op_start_micros, op_exec_micros}
       * For cpu, vector size can be larger than 1 if in tf.while_loop.
       * </pre>
       *
       * <code>map&lt;string, .tensorflow.tfprof.ExecTime&gt; cpu_execs = 5;</code>
       */

      public Builder putAllCpuExecs(
          java.util.Map<java.lang.String, tensorflow.tfprof.TfprofLog.ExecTime> values) {
        internalGetMutableCpuExecs().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.util.List<tensorflow.tfprof.TfprofLog.ExecMemory> memoryExecs_ =
        java.util.Collections.emptyList();
      private void ensureMemoryExecsIsMutable() {
        if (!((bitField0_ & 0x00000020) == 0x00000020)) {
          memoryExecs_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.ExecMemory>(memoryExecs_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.ExecMemory, tensorflow.tfprof.TfprofLog.ExecMemory.Builder, tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder> memoryExecsBuilder_;

      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.ExecMemory> getMemoryExecsList() {
        if (memoryExecsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(memoryExecs_);
        } else {
          return memoryExecsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public int getMemoryExecsCount() {
        if (memoryExecsBuilder_ == null) {
          return memoryExecs_.size();
        } else {
          return memoryExecsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public tensorflow.tfprof.TfprofLog.ExecMemory getMemoryExecs(int index) {
        if (memoryExecsBuilder_ == null) {
          return memoryExecs_.get(index);
        } else {
          return memoryExecsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder setMemoryExecs(
          int index, tensorflow.tfprof.TfprofLog.ExecMemory value) {
        if (memoryExecsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMemoryExecsIsMutable();
          memoryExecs_.set(index, value);
          onChanged();
        } else {
          memoryExecsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder setMemoryExecs(
          int index, tensorflow.tfprof.TfprofLog.ExecMemory.Builder builderForValue) {
        if (memoryExecsBuilder_ == null) {
          ensureMemoryExecsIsMutable();
          memoryExecs_.set(index, builderForValue.build());
          onChanged();
        } else {
          memoryExecsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder addMemoryExecs(tensorflow.tfprof.TfprofLog.ExecMemory value) {
        if (memoryExecsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMemoryExecsIsMutable();
          memoryExecs_.add(value);
          onChanged();
        } else {
          memoryExecsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder addMemoryExecs(
          int index, tensorflow.tfprof.TfprofLog.ExecMemory value) {
        if (memoryExecsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMemoryExecsIsMutable();
          memoryExecs_.add(index, value);
          onChanged();
        } else {
          memoryExecsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder addMemoryExecs(
          tensorflow.tfprof.TfprofLog.ExecMemory.Builder builderForValue) {
        if (memoryExecsBuilder_ == null) {
          ensureMemoryExecsIsMutable();
          memoryExecs_.add(builderForValue.build());
          onChanged();
        } else {
          memoryExecsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder addMemoryExecs(
          int index, tensorflow.tfprof.TfprofLog.ExecMemory.Builder builderForValue) {
        if (memoryExecsBuilder_ == null) {
          ensureMemoryExecsIsMutable();
          memoryExecs_.add(index, builderForValue.build());
          onChanged();
        } else {
          memoryExecsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder addAllMemoryExecs(
          java.lang.Iterable<? extends tensorflow.tfprof.TfprofLog.ExecMemory> values) {
        if (memoryExecsBuilder_ == null) {
          ensureMemoryExecsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, memoryExecs_);
          onChanged();
        } else {
          memoryExecsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder clearMemoryExecs() {
        if (memoryExecsBuilder_ == null) {
          memoryExecs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          memoryExecsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public Builder removeMemoryExecs(int index) {
        if (memoryExecsBuilder_ == null) {
          ensureMemoryExecsIsMutable();
          memoryExecs_.remove(index);
          onChanged();
        } else {
          memoryExecsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public tensorflow.tfprof.TfprofLog.ExecMemory.Builder getMemoryExecsBuilder(
          int index) {
        return getMemoryExecsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder getMemoryExecsOrBuilder(
          int index) {
        if (memoryExecsBuilder_ == null) {
          return memoryExecs_.get(index);  } else {
          return memoryExecsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public java.util.List<? extends tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder> 
           getMemoryExecsOrBuilderList() {
        if (memoryExecsBuilder_ != null) {
          return memoryExecsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(memoryExecs_);
        }
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public tensorflow.tfprof.TfprofLog.ExecMemory.Builder addMemoryExecsBuilder() {
        return getMemoryExecsFieldBuilder().addBuilder(
            tensorflow.tfprof.TfprofLog.ExecMemory.getDefaultInstance());
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public tensorflow.tfprof.TfprofLog.ExecMemory.Builder addMemoryExecsBuilder(
          int index) {
        return getMemoryExecsFieldBuilder().addBuilder(
            index, tensorflow.tfprof.TfprofLog.ExecMemory.getDefaultInstance());
      }
      /**
       * <pre>
       * Each entry to memory information of a scheduling of the node.
       * Normally, there will be multiple entries in while_loop.
       * </pre>
       *
       * <code>repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.ExecMemory.Builder> 
           getMemoryExecsBuilderList() {
        return getMemoryExecsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.ExecMemory, tensorflow.tfprof.TfprofLog.ExecMemory.Builder, tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder> 
          getMemoryExecsFieldBuilder() {
        if (memoryExecsBuilder_ == null) {
          memoryExecsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              tensorflow.tfprof.TfprofLog.ExecMemory, tensorflow.tfprof.TfprofLog.ExecMemory.Builder, tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder>(
                  memoryExecs_,
                  ((bitField0_ & 0x00000020) == 0x00000020),
                  getParentForChildren(),
                  isClean());
          memoryExecs_ = null;
        }
        return memoryExecsBuilder_;
      }

      private java.util.List<org.tensorflow.framework.AllocationRecord> allocations_ =
        java.util.Collections.emptyList();
      private void ensureAllocationsIsMutable() {
        if (!((bitField0_ & 0x00000040) == 0x00000040)) {
          allocations_ = new java.util.ArrayList<org.tensorflow.framework.AllocationRecord>(allocations_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.tensorflow.framework.AllocationRecord, org.tensorflow.framework.AllocationRecord.Builder, org.tensorflow.framework.AllocationRecordOrBuilder> allocationsBuilder_;

      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public java.util.List<org.tensorflow.framework.AllocationRecord> getAllocationsList() {
        if (allocationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(allocations_);
        } else {
          return allocationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public int getAllocationsCount() {
        if (allocationsBuilder_ == null) {
          return allocations_.size();
        } else {
          return allocationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public org.tensorflow.framework.AllocationRecord getAllocations(int index) {
        if (allocationsBuilder_ == null) {
          return allocations_.get(index);
        } else {
          return allocationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder setAllocations(
          int index, org.tensorflow.framework.AllocationRecord value) {
        if (allocationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllocationsIsMutable();
          allocations_.set(index, value);
          onChanged();
        } else {
          allocationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder setAllocations(
          int index, org.tensorflow.framework.AllocationRecord.Builder builderForValue) {
        if (allocationsBuilder_ == null) {
          ensureAllocationsIsMutable();
          allocations_.set(index, builderForValue.build());
          onChanged();
        } else {
          allocationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder addAllocations(org.tensorflow.framework.AllocationRecord value) {
        if (allocationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllocationsIsMutable();
          allocations_.add(value);
          onChanged();
        } else {
          allocationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder addAllocations(
          int index, org.tensorflow.framework.AllocationRecord value) {
        if (allocationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAllocationsIsMutable();
          allocations_.add(index, value);
          onChanged();
        } else {
          allocationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder addAllocations(
          org.tensorflow.framework.AllocationRecord.Builder builderForValue) {
        if (allocationsBuilder_ == null) {
          ensureAllocationsIsMutable();
          allocations_.add(builderForValue.build());
          onChanged();
        } else {
          allocationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder addAllocations(
          int index, org.tensorflow.framework.AllocationRecord.Builder builderForValue) {
        if (allocationsBuilder_ == null) {
          ensureAllocationsIsMutable();
          allocations_.add(index, builderForValue.build());
          onChanged();
        } else {
          allocationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder addAllAllocations(
          java.lang.Iterable<? extends org.tensorflow.framework.AllocationRecord> values) {
        if (allocationsBuilder_ == null) {
          ensureAllocationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, allocations_);
          onChanged();
        } else {
          allocationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder clearAllocations() {
        if (allocationsBuilder_ == null) {
          allocations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          allocationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public Builder removeAllocations(int index) {
        if (allocationsBuilder_ == null) {
          ensureAllocationsIsMutable();
          allocations_.remove(index);
          onChanged();
        } else {
          allocationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public org.tensorflow.framework.AllocationRecord.Builder getAllocationsBuilder(
          int index) {
        return getAllocationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public org.tensorflow.framework.AllocationRecordOrBuilder getAllocationsOrBuilder(
          int index) {
        if (allocationsBuilder_ == null) {
          return allocations_.get(index);  } else {
          return allocationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public java.util.List<? extends org.tensorflow.framework.AllocationRecordOrBuilder> 
           getAllocationsOrBuilderList() {
        if (allocationsBuilder_ != null) {
          return allocationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(allocations_);
        }
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public org.tensorflow.framework.AllocationRecord.Builder addAllocationsBuilder() {
        return getAllocationsFieldBuilder().addBuilder(
            org.tensorflow.framework.AllocationRecord.getDefaultInstance());
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public org.tensorflow.framework.AllocationRecord.Builder addAllocationsBuilder(
          int index) {
        return getAllocationsFieldBuilder().addBuilder(
            index, org.tensorflow.framework.AllocationRecord.getDefaultInstance());
      }
      /**
       * <pre>
       * The allocation and deallocation times and sizes throughout execution.
       * </pre>
       *
       * <code>repeated .tensorflow.AllocationRecord allocations = 11;</code>
       */
      public java.util.List<org.tensorflow.framework.AllocationRecord.Builder> 
           getAllocationsBuilderList() {
        return getAllocationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          org.tensorflow.framework.AllocationRecord, org.tensorflow.framework.AllocationRecord.Builder, org.tensorflow.framework.AllocationRecordOrBuilder> 
          getAllocationsFieldBuilder() {
        if (allocationsBuilder_ == null) {
          allocationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              org.tensorflow.framework.AllocationRecord, org.tensorflow.framework.AllocationRecord.Builder, org.tensorflow.framework.AllocationRecordOrBuilder>(
                  allocations_,
                  ((bitField0_ & 0x00000040) == 0x00000040),
                  getParentForChildren(),
                  isClean());
          allocations_ = null;
        }
        return allocationsBuilder_;
      }

      private com.google.protobuf.LazyStringList devices_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureDevicesIsMutable() {
        if (!((bitField0_ & 0x00000080) == 0x00000080)) {
          devices_ = new com.google.protobuf.LazyStringArrayList(devices_);
          bitField0_ |= 0x00000080;
         }
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getDevicesList() {
        return devices_.getUnmodifiableView();
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public int getDevicesCount() {
        return devices_.size();
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public java.lang.String getDevices(int index) {
        return devices_.get(index);
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public com.google.protobuf.ByteString
          getDevicesBytes(int index) {
        return devices_.getByteString(index);
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public Builder setDevices(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureDevicesIsMutable();
        devices_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public Builder addDevices(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureDevicesIsMutable();
        devices_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public Builder addAllDevices(
          java.lang.Iterable<java.lang.String> values) {
        ensureDevicesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, devices_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public Builder clearDevices() {
        devices_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The devices related to this execution.
       * </pre>
       *
       * <code>repeated string devices = 6;</code>
       */
      public Builder addDevicesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureDevicesIsMutable();
        devices_.add(value);
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.ExecProfile)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.ExecProfile)
    private static final tensorflow.tfprof.TfprofLog.ExecProfile DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.ExecProfile();
    }

    public static tensorflow.tfprof.TfprofLog.ExecProfile getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ExecProfile>
        PARSER = new com.google.protobuf.AbstractParser<ExecProfile>() {
      public ExecProfile parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new ExecProfile(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExecProfile> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExecProfile> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.ExecProfile getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExecTimeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.ExecTime)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    java.util.List<tensorflow.tfprof.TfprofLog.Tuple> 
        getTimesList();
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    tensorflow.tfprof.TfprofLog.Tuple getTimes(int index);
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    int getTimesCount();
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    java.util.List<? extends tensorflow.tfprof.TfprofLog.TupleOrBuilder> 
        getTimesOrBuilderList();
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    tensorflow.tfprof.TfprofLog.TupleOrBuilder getTimesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.ExecTime}
   */
  public  static final class ExecTime extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.ExecTime)
      ExecTimeOrBuilder {
    // Use ExecTime.newBuilder() to construct.
    private ExecTime(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ExecTime() {
      times_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private ExecTime(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                times_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.Tuple>();
                mutable_bitField0_ |= 0x00000001;
              }
              times_.add(
                  input.readMessage(tensorflow.tfprof.TfprofLog.Tuple.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          times_ = java.util.Collections.unmodifiableList(times_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecTime_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecTime_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.ExecTime.class, tensorflow.tfprof.TfprofLog.ExecTime.Builder.class);
    }

    public static final int TIMES_FIELD_NUMBER = 1;
    private java.util.List<tensorflow.tfprof.TfprofLog.Tuple> times_;
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    public java.util.List<tensorflow.tfprof.TfprofLog.Tuple> getTimesList() {
      return times_;
    }
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    public java.util.List<? extends tensorflow.tfprof.TfprofLog.TupleOrBuilder> 
        getTimesOrBuilderList() {
      return times_;
    }
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    public int getTimesCount() {
      return times_.size();
    }
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    public tensorflow.tfprof.TfprofLog.Tuple getTimes(int index) {
      return times_.get(index);
    }
    /**
     * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
     */
    public tensorflow.tfprof.TfprofLog.TupleOrBuilder getTimesOrBuilder(
        int index) {
      return times_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < times_.size(); i++) {
        output.writeMessage(1, times_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < times_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, times_.get(i));
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.ExecTime)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.ExecTime other = (tensorflow.tfprof.TfprofLog.ExecTime) obj;

      boolean result = true;
      result = result && getTimesList()
          .equals(other.getTimesList());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getTimesCount() > 0) {
        hash = (37 * hash) + TIMES_FIELD_NUMBER;
        hash = (53 * hash) + getTimesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecTime parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.ExecTime prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.ExecTime}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.ExecTime)
        tensorflow.tfprof.TfprofLog.ExecTimeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecTime_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecTime_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.ExecTime.class, tensorflow.tfprof.TfprofLog.ExecTime.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.ExecTime.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTimesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (timesBuilder_ == null) {
          times_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          timesBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecTime_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.ExecTime getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.ExecTime.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.ExecTime build() {
        tensorflow.tfprof.TfprofLog.ExecTime result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.ExecTime buildPartial() {
        tensorflow.tfprof.TfprofLog.ExecTime result = new tensorflow.tfprof.TfprofLog.ExecTime(this);
        int from_bitField0_ = bitField0_;
        if (timesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            times_ = java.util.Collections.unmodifiableList(times_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.times_ = times_;
        } else {
          result.times_ = timesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.ExecTime) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.ExecTime)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.ExecTime other) {
        if (other == tensorflow.tfprof.TfprofLog.ExecTime.getDefaultInstance()) return this;
        if (timesBuilder_ == null) {
          if (!other.times_.isEmpty()) {
            if (times_.isEmpty()) {
              times_ = other.times_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureTimesIsMutable();
              times_.addAll(other.times_);
            }
            onChanged();
          }
        } else {
          if (!other.times_.isEmpty()) {
            if (timesBuilder_.isEmpty()) {
              timesBuilder_.dispose();
              timesBuilder_ = null;
              times_ = other.times_;
              bitField0_ = (bitField0_ & ~0x00000001);
              timesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTimesFieldBuilder() : null;
            } else {
              timesBuilder_.addAllMessages(other.times_);
            }
          }
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.ExecTime parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.ExecTime) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<tensorflow.tfprof.TfprofLog.Tuple> times_ =
        java.util.Collections.emptyList();
      private void ensureTimesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          times_ = new java.util.ArrayList<tensorflow.tfprof.TfprofLog.Tuple>(times_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.Tuple, tensorflow.tfprof.TfprofLog.Tuple.Builder, tensorflow.tfprof.TfprofLog.TupleOrBuilder> timesBuilder_;

      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.Tuple> getTimesList() {
        if (timesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(times_);
        } else {
          return timesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public int getTimesCount() {
        if (timesBuilder_ == null) {
          return times_.size();
        } else {
          return timesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.Tuple getTimes(int index) {
        if (timesBuilder_ == null) {
          return times_.get(index);
        } else {
          return timesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder setTimes(
          int index, tensorflow.tfprof.TfprofLog.Tuple value) {
        if (timesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTimesIsMutable();
          times_.set(index, value);
          onChanged();
        } else {
          timesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder setTimes(
          int index, tensorflow.tfprof.TfprofLog.Tuple.Builder builderForValue) {
        if (timesBuilder_ == null) {
          ensureTimesIsMutable();
          times_.set(index, builderForValue.build());
          onChanged();
        } else {
          timesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder addTimes(tensorflow.tfprof.TfprofLog.Tuple value) {
        if (timesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTimesIsMutable();
          times_.add(value);
          onChanged();
        } else {
          timesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder addTimes(
          int index, tensorflow.tfprof.TfprofLog.Tuple value) {
        if (timesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTimesIsMutable();
          times_.add(index, value);
          onChanged();
        } else {
          timesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder addTimes(
          tensorflow.tfprof.TfprofLog.Tuple.Builder builderForValue) {
        if (timesBuilder_ == null) {
          ensureTimesIsMutable();
          times_.add(builderForValue.build());
          onChanged();
        } else {
          timesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder addTimes(
          int index, tensorflow.tfprof.TfprofLog.Tuple.Builder builderForValue) {
        if (timesBuilder_ == null) {
          ensureTimesIsMutable();
          times_.add(index, builderForValue.build());
          onChanged();
        } else {
          timesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder addAllTimes(
          java.lang.Iterable<? extends tensorflow.tfprof.TfprofLog.Tuple> values) {
        if (timesBuilder_ == null) {
          ensureTimesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, times_);
          onChanged();
        } else {
          timesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder clearTimes() {
        if (timesBuilder_ == null) {
          times_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          timesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public Builder removeTimes(int index) {
        if (timesBuilder_ == null) {
          ensureTimesIsMutable();
          times_.remove(index);
          onChanged();
        } else {
          timesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.Tuple.Builder getTimesBuilder(
          int index) {
        return getTimesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.TupleOrBuilder getTimesOrBuilder(
          int index) {
        if (timesBuilder_ == null) {
          return times_.get(index);  } else {
          return timesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public java.util.List<? extends tensorflow.tfprof.TfprofLog.TupleOrBuilder> 
           getTimesOrBuilderList() {
        if (timesBuilder_ != null) {
          return timesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(times_);
        }
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.Tuple.Builder addTimesBuilder() {
        return getTimesFieldBuilder().addBuilder(
            tensorflow.tfprof.TfprofLog.Tuple.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public tensorflow.tfprof.TfprofLog.Tuple.Builder addTimesBuilder(
          int index) {
        return getTimesFieldBuilder().addBuilder(
            index, tensorflow.tfprof.TfprofLog.Tuple.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.tfprof.Tuple times = 1;</code>
       */
      public java.util.List<tensorflow.tfprof.TfprofLog.Tuple.Builder> 
           getTimesBuilderList() {
        return getTimesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          tensorflow.tfprof.TfprofLog.Tuple, tensorflow.tfprof.TfprofLog.Tuple.Builder, tensorflow.tfprof.TfprofLog.TupleOrBuilder> 
          getTimesFieldBuilder() {
        if (timesBuilder_ == null) {
          timesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              tensorflow.tfprof.TfprofLog.Tuple, tensorflow.tfprof.TfprofLog.Tuple.Builder, tensorflow.tfprof.TfprofLog.TupleOrBuilder>(
                  times_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          times_ = null;
        }
        return timesBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.ExecTime)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.ExecTime)
    private static final tensorflow.tfprof.TfprofLog.ExecTime DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.ExecTime();
    }

    public static tensorflow.tfprof.TfprofLog.ExecTime getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ExecTime>
        PARSER = new com.google.protobuf.AbstractParser<ExecTime>() {
      public ExecTime parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new ExecTime(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExecTime> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExecTime> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.ExecTime getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExecMemoryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.ExecMemory)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This is the timestamp when the memory information was tracked.
     * </pre>
     *
     * <code>int64 memory_micros = 1;</code>
     */
    long getMemoryMicros();

    /**
     * <pre>
     * NOTE: Please don't depend on the following 4 fields yet. Due to
     * TensorFlow internal tracing issues, the numbers can be quite wrong.
     * TODO(xpan): Fix the TensorFlow internal tracing.
     * </pre>
     *
     * <code>int64 host_temp_bytes = 2;</code>
     */
    long getHostTempBytes();

    /**
     * <code>int64 host_persistent_bytes = 3;</code>
     */
    long getHostPersistentBytes();

    /**
     * <code>int64 accelerator_temp_bytes = 4;</code>
     */
    long getAcceleratorTempBytes();

    /**
     * <code>int64 accelerator_persistent_bytes = 5;</code>
     */
    long getAcceleratorPersistentBytes();

    /**
     * <pre>
     * Total bytes requested by the op.
     * </pre>
     *
     * <code>int64 requested_bytes = 6;</code>
     */
    long getRequestedBytes();

    /**
     * <pre>
     * Total bytes requested by the op and released before op end.
     * </pre>
     *
     * <code>int64 peak_bytes = 7;</code>
     */
    long getPeakBytes();

    /**
     * <pre>
     * Total bytes requested by the op and not released after op end.
     * </pre>
     *
     * <code>int64 residual_bytes = 8;</code>
     */
    long getResidualBytes();

    /**
     * <pre>
     * Total bytes output by the op (not necessarily requested by the op).
     * </pre>
     *
     * <code>int64 output_bytes = 9;</code>
     */
    long getOutputBytes();

    /**
     * <pre>
     * The total number of bytes currently allocated by the allocator if &gt;0.
     * </pre>
     *
     * <code>int64 allocator_bytes_in_use = 10;</code>
     */
    long getAllocatorBytesInUse();

    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */
    int getOutputMemoryCount();
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */
    boolean containsOutputMemory(
        int key);
    /**
     * Use {@link #getOutputMemoryMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
    getOutputMemory();
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */
    java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
    getOutputMemoryMap();
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */

    tensorflow.tfprof.TfprofLog.Memory getOutputMemoryOrDefault(
        int key,
        tensorflow.tfprof.TfprofLog.Memory defaultValue);
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */

    tensorflow.tfprof.TfprofLog.Memory getOutputMemoryOrThrow(
        int key);
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.ExecMemory}
   */
  public  static final class ExecMemory extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.ExecMemory)
      ExecMemoryOrBuilder {
    // Use ExecMemory.newBuilder() to construct.
    private ExecMemory(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ExecMemory() {
      memoryMicros_ = 0L;
      hostTempBytes_ = 0L;
      hostPersistentBytes_ = 0L;
      acceleratorTempBytes_ = 0L;
      acceleratorPersistentBytes_ = 0L;
      requestedBytes_ = 0L;
      peakBytes_ = 0L;
      residualBytes_ = 0L;
      outputBytes_ = 0L;
      allocatorBytesInUse_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private ExecMemory(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              memoryMicros_ = input.readInt64();
              break;
            }
            case 16: {

              hostTempBytes_ = input.readInt64();
              break;
            }
            case 24: {

              hostPersistentBytes_ = input.readInt64();
              break;
            }
            case 32: {

              acceleratorTempBytes_ = input.readInt64();
              break;
            }
            case 40: {

              acceleratorPersistentBytes_ = input.readInt64();
              break;
            }
            case 48: {

              requestedBytes_ = input.readInt64();
              break;
            }
            case 56: {

              peakBytes_ = input.readInt64();
              break;
            }
            case 64: {

              residualBytes_ = input.readInt64();
              break;
            }
            case 72: {

              outputBytes_ = input.readInt64();
              break;
            }
            case 80: {

              allocatorBytesInUse_ = input.readInt64();
              break;
            }
            case 90: {
              if (!((mutable_bitField0_ & 0x00000400) == 0x00000400)) {
                outputMemory_ = com.google.protobuf.MapField.newMapField(
                    OutputMemoryDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000400;
              }
              com.google.protobuf.MapEntry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
              outputMemory__ = input.readMessage(
                  OutputMemoryDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              outputMemory_.getMutableMap().put(
                  outputMemory__.getKey(), outputMemory__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecMemory_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 11:
          return internalGetOutputMemory();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecMemory_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.ExecMemory.class, tensorflow.tfprof.TfprofLog.ExecMemory.Builder.class);
    }

    private int bitField0_;
    public static final int MEMORY_MICROS_FIELD_NUMBER = 1;
    private long memoryMicros_;
    /**
     * <pre>
     * This is the timestamp when the memory information was tracked.
     * </pre>
     *
     * <code>int64 memory_micros = 1;</code>
     */
    public long getMemoryMicros() {
      return memoryMicros_;
    }

    public static final int HOST_TEMP_BYTES_FIELD_NUMBER = 2;
    private long hostTempBytes_;
    /**
     * <pre>
     * NOTE: Please don't depend on the following 4 fields yet. Due to
     * TensorFlow internal tracing issues, the numbers can be quite wrong.
     * TODO(xpan): Fix the TensorFlow internal tracing.
     * </pre>
     *
     * <code>int64 host_temp_bytes = 2;</code>
     */
    public long getHostTempBytes() {
      return hostTempBytes_;
    }

    public static final int HOST_PERSISTENT_BYTES_FIELD_NUMBER = 3;
    private long hostPersistentBytes_;
    /**
     * <code>int64 host_persistent_bytes = 3;</code>
     */
    public long getHostPersistentBytes() {
      return hostPersistentBytes_;
    }

    public static final int ACCELERATOR_TEMP_BYTES_FIELD_NUMBER = 4;
    private long acceleratorTempBytes_;
    /**
     * <code>int64 accelerator_temp_bytes = 4;</code>
     */
    public long getAcceleratorTempBytes() {
      return acceleratorTempBytes_;
    }

    public static final int ACCELERATOR_PERSISTENT_BYTES_FIELD_NUMBER = 5;
    private long acceleratorPersistentBytes_;
    /**
     * <code>int64 accelerator_persistent_bytes = 5;</code>
     */
    public long getAcceleratorPersistentBytes() {
      return acceleratorPersistentBytes_;
    }

    public static final int REQUESTED_BYTES_FIELD_NUMBER = 6;
    private long requestedBytes_;
    /**
     * <pre>
     * Total bytes requested by the op.
     * </pre>
     *
     * <code>int64 requested_bytes = 6;</code>
     */
    public long getRequestedBytes() {
      return requestedBytes_;
    }

    public static final int PEAK_BYTES_FIELD_NUMBER = 7;
    private long peakBytes_;
    /**
     * <pre>
     * Total bytes requested by the op and released before op end.
     * </pre>
     *
     * <code>int64 peak_bytes = 7;</code>
     */
    public long getPeakBytes() {
      return peakBytes_;
    }

    public static final int RESIDUAL_BYTES_FIELD_NUMBER = 8;
    private long residualBytes_;
    /**
     * <pre>
     * Total bytes requested by the op and not released after op end.
     * </pre>
     *
     * <code>int64 residual_bytes = 8;</code>
     */
    public long getResidualBytes() {
      return residualBytes_;
    }

    public static final int OUTPUT_BYTES_FIELD_NUMBER = 9;
    private long outputBytes_;
    /**
     * <pre>
     * Total bytes output by the op (not necessarily requested by the op).
     * </pre>
     *
     * <code>int64 output_bytes = 9;</code>
     */
    public long getOutputBytes() {
      return outputBytes_;
    }

    public static final int ALLOCATOR_BYTES_IN_USE_FIELD_NUMBER = 10;
    private long allocatorBytesInUse_;
    /**
     * <pre>
     * The total number of bytes currently allocated by the allocator if &gt;0.
     * </pre>
     *
     * <code>int64 allocator_bytes_in_use = 10;</code>
     */
    public long getAllocatorBytesInUse() {
      return allocatorBytesInUse_;
    }

    public static final int OUTPUT_MEMORY_FIELD_NUMBER = 11;
    private static final class OutputMemoryDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>newDefaultInstance(
                  tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecMemory_OutputMemoryEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.INT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  tensorflow.tfprof.TfprofLog.Memory.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> outputMemory_;
    private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
    internalGetOutputMemory() {
      if (outputMemory_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            OutputMemoryDefaultEntryHolder.defaultEntry);
      }
      return outputMemory_;
    }

    public int getOutputMemoryCount() {
      return internalGetOutputMemory().getMap().size();
    }
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */

    public boolean containsOutputMemory(
        int key) {
      
      return internalGetOutputMemory().getMap().containsKey(key);
    }
    /**
     * Use {@link #getOutputMemoryMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> getOutputMemory() {
      return getOutputMemoryMap();
    }
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */

    public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> getOutputMemoryMap() {
      return internalGetOutputMemory().getMap();
    }
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */

    public tensorflow.tfprof.TfprofLog.Memory getOutputMemoryOrDefault(
        int key,
        tensorflow.tfprof.TfprofLog.Memory defaultValue) {
      
      java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> map =
          internalGetOutputMemory().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The memory of each output of the operation.
     * </pre>
     *
     * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
     */

    public tensorflow.tfprof.TfprofLog.Memory getOutputMemoryOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> map =
          internalGetOutputMemory().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (memoryMicros_ != 0L) {
        output.writeInt64(1, memoryMicros_);
      }
      if (hostTempBytes_ != 0L) {
        output.writeInt64(2, hostTempBytes_);
      }
      if (hostPersistentBytes_ != 0L) {
        output.writeInt64(3, hostPersistentBytes_);
      }
      if (acceleratorTempBytes_ != 0L) {
        output.writeInt64(4, acceleratorTempBytes_);
      }
      if (acceleratorPersistentBytes_ != 0L) {
        output.writeInt64(5, acceleratorPersistentBytes_);
      }
      if (requestedBytes_ != 0L) {
        output.writeInt64(6, requestedBytes_);
      }
      if (peakBytes_ != 0L) {
        output.writeInt64(7, peakBytes_);
      }
      if (residualBytes_ != 0L) {
        output.writeInt64(8, residualBytes_);
      }
      if (outputBytes_ != 0L) {
        output.writeInt64(9, outputBytes_);
      }
      if (allocatorBytesInUse_ != 0L) {
        output.writeInt64(10, allocatorBytesInUse_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeIntegerMapTo(
          output,
          internalGetOutputMemory(),
          OutputMemoryDefaultEntryHolder.defaultEntry,
          11);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (memoryMicros_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, memoryMicros_);
      }
      if (hostTempBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, hostTempBytes_);
      }
      if (hostPersistentBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, hostPersistentBytes_);
      }
      if (acceleratorTempBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, acceleratorTempBytes_);
      }
      if (acceleratorPersistentBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, acceleratorPersistentBytes_);
      }
      if (requestedBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, requestedBytes_);
      }
      if (peakBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, peakBytes_);
      }
      if (residualBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(8, residualBytes_);
      }
      if (outputBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(9, outputBytes_);
      }
      if (allocatorBytesInUse_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(10, allocatorBytesInUse_);
      }
      for (java.util.Map.Entry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> entry
           : internalGetOutputMemory().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
        outputMemory__ = OutputMemoryDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(11, outputMemory__);
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.ExecMemory)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.ExecMemory other = (tensorflow.tfprof.TfprofLog.ExecMemory) obj;

      boolean result = true;
      result = result && (getMemoryMicros()
          == other.getMemoryMicros());
      result = result && (getHostTempBytes()
          == other.getHostTempBytes());
      result = result && (getHostPersistentBytes()
          == other.getHostPersistentBytes());
      result = result && (getAcceleratorTempBytes()
          == other.getAcceleratorTempBytes());
      result = result && (getAcceleratorPersistentBytes()
          == other.getAcceleratorPersistentBytes());
      result = result && (getRequestedBytes()
          == other.getRequestedBytes());
      result = result && (getPeakBytes()
          == other.getPeakBytes());
      result = result && (getResidualBytes()
          == other.getResidualBytes());
      result = result && (getOutputBytes()
          == other.getOutputBytes());
      result = result && (getAllocatorBytesInUse()
          == other.getAllocatorBytesInUse());
      result = result && internalGetOutputMemory().equals(
          other.internalGetOutputMemory());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MEMORY_MICROS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMemoryMicros());
      hash = (37 * hash) + HOST_TEMP_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHostTempBytes());
      hash = (37 * hash) + HOST_PERSISTENT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHostPersistentBytes());
      hash = (37 * hash) + ACCELERATOR_TEMP_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAcceleratorTempBytes());
      hash = (37 * hash) + ACCELERATOR_PERSISTENT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAcceleratorPersistentBytes());
      hash = (37 * hash) + REQUESTED_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getRequestedBytes());
      hash = (37 * hash) + PEAK_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPeakBytes());
      hash = (37 * hash) + RESIDUAL_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getResidualBytes());
      hash = (37 * hash) + OUTPUT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getOutputBytes());
      hash = (37 * hash) + ALLOCATOR_BYTES_IN_USE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAllocatorBytesInUse());
      if (!internalGetOutputMemory().getMap().isEmpty()) {
        hash = (37 * hash) + OUTPUT_MEMORY_FIELD_NUMBER;
        hash = (53 * hash) + internalGetOutputMemory().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.ExecMemory parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.ExecMemory prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.ExecMemory}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.ExecMemory)
        tensorflow.tfprof.TfprofLog.ExecMemoryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecMemory_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 11:
            return internalGetOutputMemory();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 11:
            return internalGetMutableOutputMemory();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecMemory_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.ExecMemory.class, tensorflow.tfprof.TfprofLog.ExecMemory.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.ExecMemory.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        memoryMicros_ = 0L;

        hostTempBytes_ = 0L;

        hostPersistentBytes_ = 0L;

        acceleratorTempBytes_ = 0L;

        acceleratorPersistentBytes_ = 0L;

        requestedBytes_ = 0L;

        peakBytes_ = 0L;

        residualBytes_ = 0L;

        outputBytes_ = 0L;

        allocatorBytesInUse_ = 0L;

        internalGetMutableOutputMemory().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_ExecMemory_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.ExecMemory getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.ExecMemory.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.ExecMemory build() {
        tensorflow.tfprof.TfprofLog.ExecMemory result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.ExecMemory buildPartial() {
        tensorflow.tfprof.TfprofLog.ExecMemory result = new tensorflow.tfprof.TfprofLog.ExecMemory(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.memoryMicros_ = memoryMicros_;
        result.hostTempBytes_ = hostTempBytes_;
        result.hostPersistentBytes_ = hostPersistentBytes_;
        result.acceleratorTempBytes_ = acceleratorTempBytes_;
        result.acceleratorPersistentBytes_ = acceleratorPersistentBytes_;
        result.requestedBytes_ = requestedBytes_;
        result.peakBytes_ = peakBytes_;
        result.residualBytes_ = residualBytes_;
        result.outputBytes_ = outputBytes_;
        result.allocatorBytesInUse_ = allocatorBytesInUse_;
        result.outputMemory_ = internalGetOutputMemory();
        result.outputMemory_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.ExecMemory) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.ExecMemory)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.ExecMemory other) {
        if (other == tensorflow.tfprof.TfprofLog.ExecMemory.getDefaultInstance()) return this;
        if (other.getMemoryMicros() != 0L) {
          setMemoryMicros(other.getMemoryMicros());
        }
        if (other.getHostTempBytes() != 0L) {
          setHostTempBytes(other.getHostTempBytes());
        }
        if (other.getHostPersistentBytes() != 0L) {
          setHostPersistentBytes(other.getHostPersistentBytes());
        }
        if (other.getAcceleratorTempBytes() != 0L) {
          setAcceleratorTempBytes(other.getAcceleratorTempBytes());
        }
        if (other.getAcceleratorPersistentBytes() != 0L) {
          setAcceleratorPersistentBytes(other.getAcceleratorPersistentBytes());
        }
        if (other.getRequestedBytes() != 0L) {
          setRequestedBytes(other.getRequestedBytes());
        }
        if (other.getPeakBytes() != 0L) {
          setPeakBytes(other.getPeakBytes());
        }
        if (other.getResidualBytes() != 0L) {
          setResidualBytes(other.getResidualBytes());
        }
        if (other.getOutputBytes() != 0L) {
          setOutputBytes(other.getOutputBytes());
        }
        if (other.getAllocatorBytesInUse() != 0L) {
          setAllocatorBytesInUse(other.getAllocatorBytesInUse());
        }
        internalGetMutableOutputMemory().mergeFrom(
            other.internalGetOutputMemory());
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.ExecMemory parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.ExecMemory) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long memoryMicros_ ;
      /**
       * <pre>
       * This is the timestamp when the memory information was tracked.
       * </pre>
       *
       * <code>int64 memory_micros = 1;</code>
       */
      public long getMemoryMicros() {
        return memoryMicros_;
      }
      /**
       * <pre>
       * This is the timestamp when the memory information was tracked.
       * </pre>
       *
       * <code>int64 memory_micros = 1;</code>
       */
      public Builder setMemoryMicros(long value) {
        
        memoryMicros_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the timestamp when the memory information was tracked.
       * </pre>
       *
       * <code>int64 memory_micros = 1;</code>
       */
      public Builder clearMemoryMicros() {
        
        memoryMicros_ = 0L;
        onChanged();
        return this;
      }

      private long hostTempBytes_ ;
      /**
       * <pre>
       * NOTE: Please don't depend on the following 4 fields yet. Due to
       * TensorFlow internal tracing issues, the numbers can be quite wrong.
       * TODO(xpan): Fix the TensorFlow internal tracing.
       * </pre>
       *
       * <code>int64 host_temp_bytes = 2;</code>
       */
      public long getHostTempBytes() {
        return hostTempBytes_;
      }
      /**
       * <pre>
       * NOTE: Please don't depend on the following 4 fields yet. Due to
       * TensorFlow internal tracing issues, the numbers can be quite wrong.
       * TODO(xpan): Fix the TensorFlow internal tracing.
       * </pre>
       *
       * <code>int64 host_temp_bytes = 2;</code>
       */
      public Builder setHostTempBytes(long value) {
        
        hostTempBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NOTE: Please don't depend on the following 4 fields yet. Due to
       * TensorFlow internal tracing issues, the numbers can be quite wrong.
       * TODO(xpan): Fix the TensorFlow internal tracing.
       * </pre>
       *
       * <code>int64 host_temp_bytes = 2;</code>
       */
      public Builder clearHostTempBytes() {
        
        hostTempBytes_ = 0L;
        onChanged();
        return this;
      }

      private long hostPersistentBytes_ ;
      /**
       * <code>int64 host_persistent_bytes = 3;</code>
       */
      public long getHostPersistentBytes() {
        return hostPersistentBytes_;
      }
      /**
       * <code>int64 host_persistent_bytes = 3;</code>
       */
      public Builder setHostPersistentBytes(long value) {
        
        hostPersistentBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 host_persistent_bytes = 3;</code>
       */
      public Builder clearHostPersistentBytes() {
        
        hostPersistentBytes_ = 0L;
        onChanged();
        return this;
      }

      private long acceleratorTempBytes_ ;
      /**
       * <code>int64 accelerator_temp_bytes = 4;</code>
       */
      public long getAcceleratorTempBytes() {
        return acceleratorTempBytes_;
      }
      /**
       * <code>int64 accelerator_temp_bytes = 4;</code>
       */
      public Builder setAcceleratorTempBytes(long value) {
        
        acceleratorTempBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 accelerator_temp_bytes = 4;</code>
       */
      public Builder clearAcceleratorTempBytes() {
        
        acceleratorTempBytes_ = 0L;
        onChanged();
        return this;
      }

      private long acceleratorPersistentBytes_ ;
      /**
       * <code>int64 accelerator_persistent_bytes = 5;</code>
       */
      public long getAcceleratorPersistentBytes() {
        return acceleratorPersistentBytes_;
      }
      /**
       * <code>int64 accelerator_persistent_bytes = 5;</code>
       */
      public Builder setAcceleratorPersistentBytes(long value) {
        
        acceleratorPersistentBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 accelerator_persistent_bytes = 5;</code>
       */
      public Builder clearAcceleratorPersistentBytes() {
        
        acceleratorPersistentBytes_ = 0L;
        onChanged();
        return this;
      }

      private long requestedBytes_ ;
      /**
       * <pre>
       * Total bytes requested by the op.
       * </pre>
       *
       * <code>int64 requested_bytes = 6;</code>
       */
      public long getRequestedBytes() {
        return requestedBytes_;
      }
      /**
       * <pre>
       * Total bytes requested by the op.
       * </pre>
       *
       * <code>int64 requested_bytes = 6;</code>
       */
      public Builder setRequestedBytes(long value) {
        
        requestedBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total bytes requested by the op.
       * </pre>
       *
       * <code>int64 requested_bytes = 6;</code>
       */
      public Builder clearRequestedBytes() {
        
        requestedBytes_ = 0L;
        onChanged();
        return this;
      }

      private long peakBytes_ ;
      /**
       * <pre>
       * Total bytes requested by the op and released before op end.
       * </pre>
       *
       * <code>int64 peak_bytes = 7;</code>
       */
      public long getPeakBytes() {
        return peakBytes_;
      }
      /**
       * <pre>
       * Total bytes requested by the op and released before op end.
       * </pre>
       *
       * <code>int64 peak_bytes = 7;</code>
       */
      public Builder setPeakBytes(long value) {
        
        peakBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total bytes requested by the op and released before op end.
       * </pre>
       *
       * <code>int64 peak_bytes = 7;</code>
       */
      public Builder clearPeakBytes() {
        
        peakBytes_ = 0L;
        onChanged();
        return this;
      }

      private long residualBytes_ ;
      /**
       * <pre>
       * Total bytes requested by the op and not released after op end.
       * </pre>
       *
       * <code>int64 residual_bytes = 8;</code>
       */
      public long getResidualBytes() {
        return residualBytes_;
      }
      /**
       * <pre>
       * Total bytes requested by the op and not released after op end.
       * </pre>
       *
       * <code>int64 residual_bytes = 8;</code>
       */
      public Builder setResidualBytes(long value) {
        
        residualBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total bytes requested by the op and not released after op end.
       * </pre>
       *
       * <code>int64 residual_bytes = 8;</code>
       */
      public Builder clearResidualBytes() {
        
        residualBytes_ = 0L;
        onChanged();
        return this;
      }

      private long outputBytes_ ;
      /**
       * <pre>
       * Total bytes output by the op (not necessarily requested by the op).
       * </pre>
       *
       * <code>int64 output_bytes = 9;</code>
       */
      public long getOutputBytes() {
        return outputBytes_;
      }
      /**
       * <pre>
       * Total bytes output by the op (not necessarily requested by the op).
       * </pre>
       *
       * <code>int64 output_bytes = 9;</code>
       */
      public Builder setOutputBytes(long value) {
        
        outputBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Total bytes output by the op (not necessarily requested by the op).
       * </pre>
       *
       * <code>int64 output_bytes = 9;</code>
       */
      public Builder clearOutputBytes() {
        
        outputBytes_ = 0L;
        onChanged();
        return this;
      }

      private long allocatorBytesInUse_ ;
      /**
       * <pre>
       * The total number of bytes currently allocated by the allocator if &gt;0.
       * </pre>
       *
       * <code>int64 allocator_bytes_in_use = 10;</code>
       */
      public long getAllocatorBytesInUse() {
        return allocatorBytesInUse_;
      }
      /**
       * <pre>
       * The total number of bytes currently allocated by the allocator if &gt;0.
       * </pre>
       *
       * <code>int64 allocator_bytes_in_use = 10;</code>
       */
      public Builder setAllocatorBytesInUse(long value) {
        
        allocatorBytesInUse_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The total number of bytes currently allocated by the allocator if &gt;0.
       * </pre>
       *
       * <code>int64 allocator_bytes_in_use = 10;</code>
       */
      public Builder clearAllocatorBytesInUse() {
        
        allocatorBytesInUse_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> outputMemory_;
      private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
      internalGetOutputMemory() {
        if (outputMemory_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              OutputMemoryDefaultEntryHolder.defaultEntry);
        }
        return outputMemory_;
      }
      private com.google.protobuf.MapField<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
      internalGetMutableOutputMemory() {
        onChanged();;
        if (outputMemory_ == null) {
          outputMemory_ = com.google.protobuf.MapField.newMapField(
              OutputMemoryDefaultEntryHolder.defaultEntry);
        }
        if (!outputMemory_.isMutable()) {
          outputMemory_ = outputMemory_.copy();
        }
        return outputMemory_;
      }

      public int getOutputMemoryCount() {
        return internalGetOutputMemory().getMap().size();
      }
      /**
       * <pre>
       * The memory of each output of the operation.
       * </pre>
       *
       * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
       */

      public boolean containsOutputMemory(
          int key) {
        
        return internalGetOutputMemory().getMap().containsKey(key);
      }
      /**
       * Use {@link #getOutputMemoryMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> getOutputMemory() {
        return getOutputMemoryMap();
      }
      /**
       * <pre>
       * The memory of each output of the operation.
       * </pre>
       *
       * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
       */

      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> getOutputMemoryMap() {
        return internalGetOutputMemory().getMap();
      }
      /**
       * <pre>
       * The memory of each output of the operation.
       * </pre>
       *
       * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
       */

      public tensorflow.tfprof.TfprofLog.Memory getOutputMemoryOrDefault(
          int key,
          tensorflow.tfprof.TfprofLog.Memory defaultValue) {
        
        java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> map =
            internalGetOutputMemory().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The memory of each output of the operation.
       * </pre>
       *
       * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
       */

      public tensorflow.tfprof.TfprofLog.Memory getOutputMemoryOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> map =
            internalGetOutputMemory().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearOutputMemory() {
        internalGetMutableOutputMemory().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * The memory of each output of the operation.
       * </pre>
       *
       * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
       */

      public Builder removeOutputMemory(
          int key) {
        
        internalGetMutableOutputMemory().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory>
      getMutableOutputMemory() {
        return internalGetMutableOutputMemory().getMutableMap();
      }
      /**
       * <pre>
       * The memory of each output of the operation.
       * </pre>
       *
       * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
       */
      public Builder putOutputMemory(
          int key,
          tensorflow.tfprof.TfprofLog.Memory value) {
        
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableOutputMemory().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * The memory of each output of the operation.
       * </pre>
       *
       * <code>map&lt;int32, .tensorflow.tfprof.Memory&gt; output_memory = 11;</code>
       */

      public Builder putAllOutputMemory(
          java.util.Map<java.lang.Integer, tensorflow.tfprof.TfprofLog.Memory> values) {
        internalGetMutableOutputMemory().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.ExecMemory)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.ExecMemory)
    private static final tensorflow.tfprof.TfprofLog.ExecMemory DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.ExecMemory();
    }

    public static tensorflow.tfprof.TfprofLog.ExecMemory getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ExecMemory>
        PARSER = new com.google.protobuf.AbstractParser<ExecMemory>() {
      public ExecMemory parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new ExecMemory(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExecMemory> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExecMemory> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.ExecMemory getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TupleOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.Tuple)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated int64 int64_values = 1;</code>
     */
    java.util.List<java.lang.Long> getInt64ValuesList();
    /**
     * <code>repeated int64 int64_values = 1;</code>
     */
    int getInt64ValuesCount();
    /**
     * <code>repeated int64 int64_values = 1;</code>
     */
    long getInt64Values(int index);
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.Tuple}
   */
  public  static final class Tuple extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.Tuple)
      TupleOrBuilder {
    // Use Tuple.newBuilder() to construct.
    private Tuple(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Tuple() {
      int64Values_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private Tuple(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                int64Values_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000001;
              }
              int64Values_.add(input.readInt64());
              break;
            }
            case 10: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001) && input.getBytesUntilLimit() > 0) {
                int64Values_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000001;
              }
              while (input.getBytesUntilLimit() > 0) {
                int64Values_.add(input.readInt64());
              }
              input.popLimit(limit);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          int64Values_ = java.util.Collections.unmodifiableList(int64Values_);
        }
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Tuple_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Tuple_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.Tuple.class, tensorflow.tfprof.TfprofLog.Tuple.Builder.class);
    }

    public static final int INT64_VALUES_FIELD_NUMBER = 1;
    private java.util.List<java.lang.Long> int64Values_;
    /**
     * <code>repeated int64 int64_values = 1;</code>
     */
    public java.util.List<java.lang.Long>
        getInt64ValuesList() {
      return int64Values_;
    }
    /**
     * <code>repeated int64 int64_values = 1;</code>
     */
    public int getInt64ValuesCount() {
      return int64Values_.size();
    }
    /**
     * <code>repeated int64 int64_values = 1;</code>
     */
    public long getInt64Values(int index) {
      return int64Values_.get(index);
    }
    private int int64ValuesMemoizedSerializedSize = -1;

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (getInt64ValuesList().size() > 0) {
        output.writeUInt32NoTag(10);
        output.writeUInt32NoTag(int64ValuesMemoizedSerializedSize);
      }
      for (int i = 0; i < int64Values_.size(); i++) {
        output.writeInt64NoTag(int64Values_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < int64Values_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(int64Values_.get(i));
        }
        size += dataSize;
        if (!getInt64ValuesList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        int64ValuesMemoizedSerializedSize = dataSize;
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.Tuple)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.Tuple other = (tensorflow.tfprof.TfprofLog.Tuple) obj;

      boolean result = true;
      result = result && getInt64ValuesList()
          .equals(other.getInt64ValuesList());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getInt64ValuesCount() > 0) {
        hash = (37 * hash) + INT64_VALUES_FIELD_NUMBER;
        hash = (53 * hash) + getInt64ValuesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.Tuple parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.Tuple prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.Tuple}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.Tuple)
        tensorflow.tfprof.TfprofLog.TupleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Tuple_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Tuple_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.Tuple.class, tensorflow.tfprof.TfprofLog.Tuple.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.Tuple.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        int64Values_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Tuple_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.Tuple getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.Tuple.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.Tuple build() {
        tensorflow.tfprof.TfprofLog.Tuple result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.Tuple buildPartial() {
        tensorflow.tfprof.TfprofLog.Tuple result = new tensorflow.tfprof.TfprofLog.Tuple(this);
        int from_bitField0_ = bitField0_;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          int64Values_ = java.util.Collections.unmodifiableList(int64Values_);
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.int64Values_ = int64Values_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.Tuple) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.Tuple)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.Tuple other) {
        if (other == tensorflow.tfprof.TfprofLog.Tuple.getDefaultInstance()) return this;
        if (!other.int64Values_.isEmpty()) {
          if (int64Values_.isEmpty()) {
            int64Values_ = other.int64Values_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureInt64ValuesIsMutable();
            int64Values_.addAll(other.int64Values_);
          }
          onChanged();
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.Tuple parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.Tuple) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<java.lang.Long> int64Values_ = java.util.Collections.emptyList();
      private void ensureInt64ValuesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          int64Values_ = new java.util.ArrayList<java.lang.Long>(int64Values_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <code>repeated int64 int64_values = 1;</code>
       */
      public java.util.List<java.lang.Long>
          getInt64ValuesList() {
        return java.util.Collections.unmodifiableList(int64Values_);
      }
      /**
       * <code>repeated int64 int64_values = 1;</code>
       */
      public int getInt64ValuesCount() {
        return int64Values_.size();
      }
      /**
       * <code>repeated int64 int64_values = 1;</code>
       */
      public long getInt64Values(int index) {
        return int64Values_.get(index);
      }
      /**
       * <code>repeated int64 int64_values = 1;</code>
       */
      public Builder setInt64Values(
          int index, long value) {
        ensureInt64ValuesIsMutable();
        int64Values_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 int64_values = 1;</code>
       */
      public Builder addInt64Values(long value) {
        ensureInt64ValuesIsMutable();
        int64Values_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 int64_values = 1;</code>
       */
      public Builder addAllInt64Values(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureInt64ValuesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, int64Values_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 int64_values = 1;</code>
       */
      public Builder clearInt64Values() {
        int64Values_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.Tuple)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.Tuple)
    private static final tensorflow.tfprof.TfprofLog.Tuple DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.Tuple();
    }

    public static tensorflow.tfprof.TfprofLog.Tuple getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Tuple>
        PARSER = new com.google.protobuf.AbstractParser<Tuple>() {
      public Tuple parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new Tuple(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Tuple> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Tuple> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.Tuple getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MemoryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.tfprof.Memory)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>int64 bytes = 1;</code>
     */
    long getBytes();

    /**
     * <code>uint64 ptr = 2;</code>
     */
    long getPtr();
  }
  /**
   * Protobuf type {@code tensorflow.tfprof.Memory}
   */
  public  static final class Memory extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.tfprof.Memory)
      MemoryOrBuilder {
    // Use Memory.newBuilder() to construct.
    private Memory(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Memory() {
      bytes_ = 0L;
      ptr_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();
    }
    private Memory(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!input.skipField(tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              bytes_ = input.readInt64();
              break;
            }
            case 16: {

              ptr_ = input.readUInt64();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Memory_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Memory_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              tensorflow.tfprof.TfprofLog.Memory.class, tensorflow.tfprof.TfprofLog.Memory.Builder.class);
    }

    public static final int BYTES_FIELD_NUMBER = 1;
    private long bytes_;
    /**
     * <code>int64 bytes = 1;</code>
     */
    public long getBytes() {
      return bytes_;
    }

    public static final int PTR_FIELD_NUMBER = 2;
    private long ptr_;
    /**
     * <code>uint64 ptr = 2;</code>
     */
    public long getPtr() {
      return ptr_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (bytes_ != 0L) {
        output.writeInt64(1, bytes_);
      }
      if (ptr_ != 0L) {
        output.writeUInt64(2, ptr_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (bytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, bytes_);
      }
      if (ptr_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, ptr_);
      }
      memoizedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof tensorflow.tfprof.TfprofLog.Memory)) {
        return super.equals(obj);
      }
      tensorflow.tfprof.TfprofLog.Memory other = (tensorflow.tfprof.TfprofLog.Memory) obj;

      boolean result = true;
      result = result && (getBytes()
          == other.getBytes());
      result = result && (getPtr()
          == other.getPtr());
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getBytes());
      hash = (37 * hash) + PTR_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPtr());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static tensorflow.tfprof.TfprofLog.Memory parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(tensorflow.tfprof.TfprofLog.Memory prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tensorflow.tfprof.Memory}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.tfprof.Memory)
        tensorflow.tfprof.TfprofLog.MemoryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Memory_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Memory_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                tensorflow.tfprof.TfprofLog.Memory.class, tensorflow.tfprof.TfprofLog.Memory.Builder.class);
      }

      // Construct using tensorflow.tfprof.TfprofLog.Memory.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        bytes_ = 0L;

        ptr_ = 0L;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return tensorflow.tfprof.TfprofLog.internal_static_tensorflow_tfprof_Memory_descriptor;
      }

      public tensorflow.tfprof.TfprofLog.Memory getDefaultInstanceForType() {
        return tensorflow.tfprof.TfprofLog.Memory.getDefaultInstance();
      }

      public tensorflow.tfprof.TfprofLog.Memory build() {
        tensorflow.tfprof.TfprofLog.Memory result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public tensorflow.tfprof.TfprofLog.Memory buildPartial() {
        tensorflow.tfprof.TfprofLog.Memory result = new tensorflow.tfprof.TfprofLog.Memory(this);
        result.bytes_ = bytes_;
        result.ptr_ = ptr_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof tensorflow.tfprof.TfprofLog.Memory) {
          return mergeFrom((tensorflow.tfprof.TfprofLog.Memory)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(tensorflow.tfprof.TfprofLog.Memory other) {
        if (other == tensorflow.tfprof.TfprofLog.Memory.getDefaultInstance()) return this;
        if (other.getBytes() != 0L) {
          setBytes(other.getBytes());
        }
        if (other.getPtr() != 0L) {
          setPtr(other.getPtr());
        }
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        tensorflow.tfprof.TfprofLog.Memory parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (tensorflow.tfprof.TfprofLog.Memory) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long bytes_ ;
      /**
       * <code>int64 bytes = 1;</code>
       */
      public long getBytes() {
        return bytes_;
      }
      /**
       * <code>int64 bytes = 1;</code>
       */
      public Builder setBytes(long value) {
        
        bytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 bytes = 1;</code>
       */
      public Builder clearBytes() {
        
        bytes_ = 0L;
        onChanged();
        return this;
      }

      private long ptr_ ;
      /**
       * <code>uint64 ptr = 2;</code>
       */
      public long getPtr() {
        return ptr_;
      }
      /**
       * <code>uint64 ptr = 2;</code>
       */
      public Builder setPtr(long value) {
        
        ptr_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>uint64 ptr = 2;</code>
       */
      public Builder clearPtr() {
        
        ptr_ = 0L;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return this;
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.tfprof.Memory)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.tfprof.Memory)
    private static final tensorflow.tfprof.TfprofLog.Memory DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new tensorflow.tfprof.TfprofLog.Memory();
    }

    public static tensorflow.tfprof.TfprofLog.Memory getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Memory>
        PARSER = new com.google.protobuf.AbstractParser<Memory>() {
      public Memory parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new Memory(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Memory> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Memory> getParserForType() {
      return PARSER;
    }

    public tensorflow.tfprof.TfprofLog.Memory getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_CodeDef_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_CodeDef_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_CodeDef_Trace_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_CodeDef_Trace_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_OpLogEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_OpLogEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_OpLogProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_OpLogProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_OpLogProto_IdToStringEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_OpLogProto_IdToStringEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileProto_NodesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileProto_NodesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileProto_IdToStringEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileProto_IdToStringEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_InputsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_InputsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_InputShapesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_InputShapesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_OutputsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_OutputsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_OutputShapesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_OutputShapesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_SrcOutputIndexEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_SrcOutputIndexEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_AttrsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_AttrsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ProfileNode_ExecsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ProfileNode_ExecsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ExecProfile_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ExecProfile_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ExecProfile_AcceleratorExecsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ExecProfile_AcceleratorExecsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ExecProfile_CpuExecsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ExecProfile_CpuExecsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ExecTime_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ExecTime_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ExecMemory_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ExecMemory_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_ExecMemory_OutputMemoryEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_ExecMemory_OutputMemoryEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_Tuple_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_Tuple_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_tfprof_Memory_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_tfprof_Memory_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n)tensorflow/core/profiler/tfprof_log.pr" +
      "oto\022\021tensorflow.tfprof\032*tensorflow/core/" +
      "framework/attr_value.proto\032*tensorflow/c" +
      "ore/framework/step_stats.proto\"\337\001\n\007CodeD" +
      "ef\0220\n\006traces\030\001 \003(\0132 .tensorflow.tfprof.C" +
      "odeDef.Trace\032\241\001\n\005Trace\022\020\n\004file\030\001 \001(\tB\002\030\001" +
      "\022\017\n\007file_id\030\006 \001(\003\022\016\n\006lineno\030\002 \001(\005\022\024\n\010fun" +
      "ction\030\003 \001(\tB\002\030\001\022\023\n\013function_id\030\007 \001(\003\022\020\n\004" +
      "line\030\004 \001(\tB\002\030\001\022\017\n\007line_id\030\010 \001(\003\022\027\n\017func_" +
      "start_line\030\005 \001(\005\"j\n\nOpLogEntry\022\014\n\004name\030\001",
      " \001(\t\022\021\n\tfloat_ops\030\002 \001(\003\022\r\n\005types\030\003 \003(\t\022," +
      "\n\010code_def\030\004 \001(\0132\032.tensorflow.tfprof.Cod" +
      "eDef\"\270\001\n\nOpLogProto\0222\n\013log_entries\030\001 \003(\013" +
      "2\035.tensorflow.tfprof.OpLogEntry\022C\n\014id_to" +
      "_string\030\002 \003(\0132-.tensorflow.tfprof.OpLogP" +
      "roto.IdToStringEntry\0321\n\017IdToStringEntry\022" +
      "\013\n\003key\030\001 \001(\003\022\r\n\005value\030\002 \001(\t:\0028\001\"\324\002\n\014Prof" +
      "ileProto\0229\n\005nodes\030\001 \003(\0132*.tensorflow.tfp" +
      "rof.ProfileProto.NodesEntry\022\021\n\thas_trace" +
      "\030\002 \001(\010\022\037\n\027miss_accelerator_stream\030\005 \001(\010\022",
      "\r\n\005steps\030\003 \003(\003\022E\n\014id_to_string\030\004 \003(\0132/.t" +
      "ensorflow.tfprof.ProfileProto.IdToString" +
      "Entry\032L\n\nNodesEntry\022\013\n\003key\030\001 \001(\003\022-\n\005valu" +
      "e\030\002 \001(\0132\036.tensorflow.tfprof.ProfileNode:" +
      "\0028\001\0321\n\017IdToStringEntry\022\013\n\003key\030\001 \001(\003\022\r\n\005v" +
      "alue\030\002 \001(\t:\0028\001\"\323\010\n\013ProfileNode\022\014\n\004name\030\001" +
      " \001(\t\022\n\n\002op\030\t \001(\t\022\n\n\002id\030\r \001(\003\022:\n\006inputs\030\002" +
      " \003(\0132*.tensorflow.tfprof.ProfileNode.Inp" +
      "utsEntry\022E\n\014input_shapes\030\020 \003(\0132/.tensorf" +
      "low.tfprof.ProfileNode.InputShapesEntry\022",
      "<\n\007outputs\030\003 \003(\0132+.tensorflow.tfprof.Pro" +
      "fileNode.OutputsEntry\022G\n\routput_shapes\030\017" +
      " \003(\01320.tensorflow.tfprof.ProfileNode.Out" +
      "putShapesEntry\022L\n\020src_output_index\030\016 \003(\013" +
      "22.tensorflow.tfprof.ProfileNode.SrcOutp" +
      "utIndexEntry\022\r\n\005shape\030\004 \003(\003\022\020\n\010op_types\030" +
      "\005 \003(\t\022\030\n\020canonical_device\030\006 \001(\t\022\023\n\013host_" +
      "device\030\007 \001(\t\022\021\n\tfloat_ops\030\010 \001(\003\022)\n\005trace" +
      "\030\n \001(\0132\032.tensorflow.tfprof.CodeDef\0228\n\005at" +
      "trs\030\013 \003(\0132).tensorflow.tfprof.ProfileNod",
      "e.AttrsEntry\0228\n\005execs\030\014 \003(\0132).tensorflow" +
      ".tfprof.ProfileNode.ExecsEntry\032-\n\013Inputs" +
      "Entry\022\013\n\003key\030\001 \001(\005\022\r\n\005value\030\002 \001(\003:\0028\001\032L\n" +
      "\020InputShapesEntry\022\013\n\003key\030\001 \001(\005\022\'\n\005value\030" +
      "\002 \001(\0132\030.tensorflow.tfprof.Tuple:\0028\001\032.\n\014O" +
      "utputsEntry\022\013\n\003key\030\001 \001(\005\022\r\n\005value\030\002 \001(\003:" +
      "\0028\001\032M\n\021OutputShapesEntry\022\013\n\003key\030\001 \001(\005\022\'\n" +
      "\005value\030\002 \001(\0132\030.tensorflow.tfprof.Tuple:\002" +
      "8\001\0325\n\023SrcOutputIndexEntry\022\013\n\003key\030\001 \001(\003\022\r" +
      "\n\005value\030\002 \001(\005:\0028\001\032C\n\nAttrsEntry\022\013\n\003key\030\001",
      " \001(\t\022$\n\005value\030\002 \001(\0132\025.tensorflow.AttrVal" +
      "ue:\0028\001\032L\n\nExecsEntry\022\013\n\003key\030\001 \001(\003\022-\n\005val" +
      "ue\030\002 \001(\0132\036.tensorflow.tfprof.ExecProfile" +
      ":\0028\001\"\204\004\n\013ExecProfile\022\021\n\trun_count\030\001 \001(\003\022" +
      "\030\n\020all_start_micros\030\002 \001(\003\022\031\n\021latest_end_" +
      "micros\030\003 \001(\003\022O\n\021accelerator_execs\030\004 \003(\0132" +
      "4.tensorflow.tfprof.ExecProfile.Accelera" +
      "torExecsEntry\022?\n\tcpu_execs\030\005 \003(\0132,.tenso" +
      "rflow.tfprof.ExecProfile.CpuExecsEntry\0223" +
      "\n\014memory_execs\030\007 \003(\0132\035.tensorflow.tfprof",
      ".ExecMemory\0221\n\013allocations\030\013 \003(\0132\034.tenso" +
      "rflow.AllocationRecord\022\017\n\007devices\030\006 \003(\t\032" +
      "T\n\025AcceleratorExecsEntry\022\013\n\003key\030\001 \001(\t\022*\n" +
      "\005value\030\002 \001(\0132\033.tensorflow.tfprof.ExecTim" +
      "e:\0028\001\032L\n\rCpuExecsEntry\022\013\n\003key\030\001 \001(\t\022*\n\005v" +
      "alue\030\002 \001(\0132\033.tensorflow.tfprof.ExecTime:" +
      "\0028\001\"3\n\010ExecTime\022\'\n\005times\030\001 \003(\0132\030.tensorf" +
      "low.tfprof.Tuple\"\264\003\n\nExecMemory\022\025\n\rmemor" +
      "y_micros\030\001 \001(\003\022\027\n\017host_temp_bytes\030\002 \001(\003\022" +
      "\035\n\025host_persistent_bytes\030\003 \001(\003\022\036\n\026accele",
      "rator_temp_bytes\030\004 \001(\003\022$\n\034accelerator_pe" +
      "rsistent_bytes\030\005 \001(\003\022\027\n\017requested_bytes\030" +
      "\006 \001(\003\022\022\n\npeak_bytes\030\007 \001(\003\022\026\n\016residual_by" +
      "tes\030\010 \001(\003\022\024\n\014output_bytes\030\t \001(\003\022\036\n\026alloc" +
      "ator_bytes_in_use\030\n \001(\003\022F\n\routput_memory" +
      "\030\013 \003(\0132/.tensorflow.tfprof.ExecMemory.Ou" +
      "tputMemoryEntry\032N\n\021OutputMemoryEntry\022\013\n\003" +
      "key\030\001 \001(\005\022(\n\005value\030\002 \001(\0132\031.tensorflow.tf" +
      "prof.Memory:\0028\001\"\035\n\005Tuple\022\024\n\014int64_values" +
      "\030\001 \003(\003\"$\n\006Memory\022\r\n\005bytes\030\001 \001(\003\022\013\n\003ptr\030\002",
      " \001(\004b\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          org.tensorflow.framework.AttrValueProtos.getDescriptor(),
          org.tensorflow.framework.StepStatsProtos.getDescriptor(),
        }, assigner);
    internal_static_tensorflow_tfprof_CodeDef_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_tensorflow_tfprof_CodeDef_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_CodeDef_descriptor,
        new java.lang.String[] { "Traces", });
    internal_static_tensorflow_tfprof_CodeDef_Trace_descriptor =
      internal_static_tensorflow_tfprof_CodeDef_descriptor.getNestedTypes().get(0);
    internal_static_tensorflow_tfprof_CodeDef_Trace_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_CodeDef_Trace_descriptor,
        new java.lang.String[] { "File", "FileId", "Lineno", "Function", "FunctionId", "Line", "LineId", "FuncStartLine", });
    internal_static_tensorflow_tfprof_OpLogEntry_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_tensorflow_tfprof_OpLogEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_OpLogEntry_descriptor,
        new java.lang.String[] { "Name", "FloatOps", "Types", "CodeDef", });
    internal_static_tensorflow_tfprof_OpLogProto_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_tensorflow_tfprof_OpLogProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_OpLogProto_descriptor,
        new java.lang.String[] { "LogEntries", "IdToString", });
    internal_static_tensorflow_tfprof_OpLogProto_IdToStringEntry_descriptor =
      internal_static_tensorflow_tfprof_OpLogProto_descriptor.getNestedTypes().get(0);
    internal_static_tensorflow_tfprof_OpLogProto_IdToStringEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_OpLogProto_IdToStringEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileProto_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_tensorflow_tfprof_ProfileProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileProto_descriptor,
        new java.lang.String[] { "Nodes", "HasTrace", "MissAcceleratorStream", "Steps", "IdToString", });
    internal_static_tensorflow_tfprof_ProfileProto_NodesEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileProto_descriptor.getNestedTypes().get(0);
    internal_static_tensorflow_tfprof_ProfileProto_NodesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileProto_NodesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileProto_IdToStringEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileProto_descriptor.getNestedTypes().get(1);
    internal_static_tensorflow_tfprof_ProfileProto_IdToStringEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileProto_IdToStringEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileNode_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_tensorflow_tfprof_ProfileNode_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_descriptor,
        new java.lang.String[] { "Name", "Op", "Id", "Inputs", "InputShapes", "Outputs", "OutputShapes", "SrcOutputIndex", "Shape", "OpTypes", "CanonicalDevice", "HostDevice", "FloatOps", "Trace", "Attrs", "Execs", });
    internal_static_tensorflow_tfprof_ProfileNode_InputsEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileNode_descriptor.getNestedTypes().get(0);
    internal_static_tensorflow_tfprof_ProfileNode_InputsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_InputsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileNode_InputShapesEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileNode_descriptor.getNestedTypes().get(1);
    internal_static_tensorflow_tfprof_ProfileNode_InputShapesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_InputShapesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileNode_OutputsEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileNode_descriptor.getNestedTypes().get(2);
    internal_static_tensorflow_tfprof_ProfileNode_OutputsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_OutputsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileNode_OutputShapesEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileNode_descriptor.getNestedTypes().get(3);
    internal_static_tensorflow_tfprof_ProfileNode_OutputShapesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_OutputShapesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileNode_SrcOutputIndexEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileNode_descriptor.getNestedTypes().get(4);
    internal_static_tensorflow_tfprof_ProfileNode_SrcOutputIndexEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_SrcOutputIndexEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileNode_AttrsEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileNode_descriptor.getNestedTypes().get(5);
    internal_static_tensorflow_tfprof_ProfileNode_AttrsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_AttrsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ProfileNode_ExecsEntry_descriptor =
      internal_static_tensorflow_tfprof_ProfileNode_descriptor.getNestedTypes().get(6);
    internal_static_tensorflow_tfprof_ProfileNode_ExecsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ProfileNode_ExecsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ExecProfile_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_tensorflow_tfprof_ExecProfile_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ExecProfile_descriptor,
        new java.lang.String[] { "RunCount", "AllStartMicros", "LatestEndMicros", "AcceleratorExecs", "CpuExecs", "MemoryExecs", "Allocations", "Devices", });
    internal_static_tensorflow_tfprof_ExecProfile_AcceleratorExecsEntry_descriptor =
      internal_static_tensorflow_tfprof_ExecProfile_descriptor.getNestedTypes().get(0);
    internal_static_tensorflow_tfprof_ExecProfile_AcceleratorExecsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ExecProfile_AcceleratorExecsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ExecProfile_CpuExecsEntry_descriptor =
      internal_static_tensorflow_tfprof_ExecProfile_descriptor.getNestedTypes().get(1);
    internal_static_tensorflow_tfprof_ExecProfile_CpuExecsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ExecProfile_CpuExecsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_ExecTime_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_tensorflow_tfprof_ExecTime_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ExecTime_descriptor,
        new java.lang.String[] { "Times", });
    internal_static_tensorflow_tfprof_ExecMemory_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_tensorflow_tfprof_ExecMemory_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ExecMemory_descriptor,
        new java.lang.String[] { "MemoryMicros", "HostTempBytes", "HostPersistentBytes", "AcceleratorTempBytes", "AcceleratorPersistentBytes", "RequestedBytes", "PeakBytes", "ResidualBytes", "OutputBytes", "AllocatorBytesInUse", "OutputMemory", });
    internal_static_tensorflow_tfprof_ExecMemory_OutputMemoryEntry_descriptor =
      internal_static_tensorflow_tfprof_ExecMemory_descriptor.getNestedTypes().get(0);
    internal_static_tensorflow_tfprof_ExecMemory_OutputMemoryEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_ExecMemory_OutputMemoryEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_tensorflow_tfprof_Tuple_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_tensorflow_tfprof_Tuple_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_Tuple_descriptor,
        new java.lang.String[] { "Int64Values", });
    internal_static_tensorflow_tfprof_Memory_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_tensorflow_tfprof_Memory_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_tfprof_Memory_descriptor,
        new java.lang.String[] { "Bytes", "Ptr", });
    org.tensorflow.framework.AttrValueProtos.getDescriptor();
    org.tensorflow.framework.StepStatsProtos.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
